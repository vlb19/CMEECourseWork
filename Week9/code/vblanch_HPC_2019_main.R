#!/usr/bin/env Rscript

# CMEE 2019 HPC excercises R code main proforma
# you don't HAVE to use this but it will be very helpful.  If you opt to write everything yourself from scratch please ensure you use EXACTLY the same function and parameter names and beware that you may loose marks if it doesn't work properly because of not using the proforma.

name <- "Victoria Blanchard"
preferred_name <- "Viki"
email <- "vlb19@ic.ac.uk"
username <- "vlb19"
personal_speciation_rate <- 0.002 # will be assigned to each person individually in class and should be between 0.002 and 0.007

rm(list = ls())

# Question 1 - Calculate species richness
species_richness <- function(community){
  
  # Count number of unique species in the community
  length(unique(community)) 
}


# Question 2 - Generate initial state for your simulation community
init_community_max <- function(size){
  # Create vector sequence of length 'size'
  seq(size) 
}


# Question 3 - Generate alternative initial state for simulation
init_community_min <- function(size){
  
  # Create a vector of ones of size 'size'
  vec <- c(rep(1, size)) 
  return(vec)
}


# Question 4 - Choose two random numbers between 1 and max_value
choose_two <- function(max_value){
  
  # From range 1:max_value, sample 2 numbers
  sample(1:max_value, 2) 
}


# Question 5 - Perform a single step of a simple neutral model
neutral_step <- function(community){

  #store the two numbers generated by the choose_two function
  choices <- choose_two(length(community)) 
  #replace the number indexed by the first choice with the number indexed by the second choice
  community[choices[1]] <- community[choices[2]] 
  
  return(community)
}


# Question 6 - Simulate several neutral_steps on a community so that a generation has passed 
neutral_generation <- function(community){
  #randomly round halved odd community sizes up or down
  steps = round(jitter(length(community)/2, amount = 0.1))
  for (i in 1:steps){
    # perform a neutral step on the community x/2 number of times
    community <- neutral_step(community) 
  }
  return(community)
}

# Question 7 - run neutral theory simulation for duration number of generations
neutral_time_series <- function(community,duration)  {
  # Set empty richness vector
  richness <- c(species_richness(community)) 

  # For each generation run neutral_generation on the community
  for (generation in 1:duration) {
    community <- neutral_generation(community)
    r = species_richness(community)
    richness <- c(richness, r)
    } 

  # return species richness of the final community
  return(richness)
}

# Question 8 Run the species model under certain conditions
question_8 <- function() {
  graphics.off() # clear any existing graphs and plot your graph within the R window
  x <- c()
  y <- c()
  duration = 200
  richness <- neutral_time_series(init_community_max(100),duration)
  for (i in 1:duration){
    y <- c(y, richness[i])
    x <- c(x, i)
  }
  plot(x,xlab = "Generation", y, ylab = "Species Richness", col = "magenta4", bg = "magenta2", pch = 22, lines(x,y))

  return("The system will always converge to 1 if you wait long enough. This is because impenetrable groups form and these spread across all connected groups until every individual is replaced by a single species.")
}

# Question 9 - Perform a step of a neutral model with speciation
neutral_step_speciation <- function(community,speciation_rate)  {
  newspecies <- runif(1) # generate a random number between 0 and 1
  
  # if the random selection is above the speciation rate run the neutral step
  if (newspecies > speciation_rate) {
    community <- neutral_step (community)

  # otherwise replace an individual with a new species
  } else {
    #store the two numbers generated by the choose_two function
    choices <- choose_two(length(community)) 
    #replace the number indexed with new species ID (maximum number in the community and adding one)
    community[choices[1]] <- max(community)+1
  }
  return(community)                                                      
}

# Question 10
neutral_generation_speciation <- function(community,speciation_rate)  {
  #randomly round halved odd community sizes up or down
  steps = round(jitter(length(community)/2, amount = 0.1))
  for (i in 1:steps){
    # perform a neutral step on the community x/2 number of times
    community <- neutral_step_speciation(community,speciation_rate)
  }

  return(community)
}
  

# Question 11
neutral_time_series_speciation <- function(community,speciation_rate,duration)  {
  # Set empty richness vector
  richness <- c(species_richness(community)) 

  # For each generation run neutral_generation on the community
  for (generation in 1:duration) {
    community <- neutral_generation_speciation(community, speciation_rate)
    r = species_richness(community)
    richness <- c(richness, r)
    } 

  # return species richness of the final community
  return(richness)
}

# Question 12
question_12 <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()

  #set initial conditions
  speciation_rate = 0.1
  duration = 200
  
  # run a neutral theory simulation
  richnessmax <- neutral_time_series_speciation(init_community_max(100), speciation_rate, duration)
  richnessmin <- neutral_time_series_speciation(init_community_min(100), speciation_rate, duration)
  
  # plot two time series on the same axis
  x <- c(0:duration) #set generation on x axis
  plot(x,xlab = "Generation", richnessmax, ylab = "Species Richness", col = "magenta4", bg = "magenta2", pch = 22, type = 'l')
  lines(richnessmin, col="blue")
}

# Question 13 - tell you what the species abundances are
species_abundance <- function(community)  {
  table <- table(community) # store unique identities in first row and counts in second row
  sort(table, decreasing = TRUE) # sort by decreasing abundance of each species
  
}

# Question 14
octaves <- function(abundance_vector) {
  # Take a log2 value of the abundance vector
  # Add 1 to this to account for the presence of zeros
  # Round to the lower integer 
  # Bin these values
  tabulate(floor(log2(abundance_vector))+1)
}

# Question 15
sum_vect <- function(x, y) {
  # sum two vectors (x and y) after making both vectors
  # the same length
  diff <- length(x)-length(y)
  if (diff > 0) {
    y <- c(y, rep(0, abs(diff))) }
  if (diff < 0) {
    x <- c(x, rep(0, abs(diff))) }
  vector_sum <- x + y
  return(vector_sum)
}

# Question 16 
question_16 <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()

  #Set starting values for temporary variables
  richnessmax <- init_community_max(100)
  richnessmin <- init_community_min(100)
  speciation_rate = 0.1
  duration = 200
  generations = 2000
  averagenumber = 0
  
      # Run neutral model for a 'burn in' period of 200 generations
      for (i in 1:duration) {
        richnessmax <- neutral_generation_speciation(richnessmax, speciation_rate)
        richnessmin <- neutral_generation_speciation(richnessmin, speciation_rate)
      }

      #Record species abundance octave vectors
      octavesmin <- octaves(species_abundance(richnessmin))
      octavesmax <- octaves(species_abundance(richnessmax))
      
      #Continue simulation for a further 2000 generations
      for (x in 1:generations) {
        richnessmax <- neutral_generation_speciation(richnessmax, speciation_rate)
        richnessmin <- neutral_generation_speciation(richnessmin, speciation_rate)
        if (x%%20 == 0) {
          averagenumber = averagenumber+1 #set a counter for each iteration
          octavesmin <- sum_vect(octavesmin, octaves(species_abundance(richnessmin)))
          octavesmax <- sum_vect(octavesmax, octaves(species_abundance(richnessmax)))
          }
      }
      # Calculate average octaves
      averagemaxoctaves <- octavesmax/averagenumber
      averageminoctaves <- octavesmin/averagenumber

      # Plot bar charts of average 
      par(mfrow=c(1,2))
      barplot(averagemaxoctaves,generations)
      barplot(averageminoctaves,generations)
      
  return ("The initial condition does not matter for the final outcome because after the initial burn-in period (excluded here) both populations tend towards the same octave number. We could summise this would happen from the results of question 12")
}

# Question 17
cluster_run <- function(speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, output_file_name)  {
  
}

# Questions 18 and 19 involve writing code elsewhere to run your simulations on the cluster

# Question 20 
process_cluster_results <- function()  {
  # clear any existing graphs and plot your graph within the R window
  combined_results <- list() #create your list output here to return
  return(combined_results)
}

# Question 21
question_21 <- function()  {
  return("type your written answer here")
}

# Question 22
question_22 <- function()  {
  return("type your written answer here")
}

# Question 23
chaos_game <- function()  {
  # clear any existing graphs and plot your graph within the R window
  dev.off
  A = c(0,0)
  B = c(3,4)
  C = c(4,1)
  X = c(0,0)
  plot(50,50, points(A,B,C))
  return("type your written answer here")
}

# Question 24
turtle <- function(start_position, direction, length)  {

  return() # you should return your endpoint here.
}

# Question 25
elbow <- function(start_position, direction, length)  {
  
}

# Question 26
spiral <- function(start_position, direction, length)  {
  return("type your written answer here")
}

# Question 27
draw_spiral <- function()  {
  # clear any existing graphs and plot your graph within the R window
  
}

# Question 28
tree <- function(start_position, direction, length)  {
  
}
draw_tree <- function()  {
  # clear any existing graphs and plot your graph within the R window
}

# Question 29
fern <- function(start_position, direction, length)  {
  
}
draw_fern <- function()  {
  # clear any existing graphs and plot your graph within the R window
}

# Question 30
fern2 <- function(start_position, direction, length)  {
  
}
draw_fern2 <- function()  {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge questions - these are optional, substantially harder, and a maximum of 16% is available for doing them.  

# Challenge question A
Challenge_A <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question B
Challenge_B <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question C
Challenge_C <- function() {
  # clear any existing graphs and plot your graph within the R window
}

# Challenge question D
Challenge_D <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question E
Challenge_E <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question F
Challenge_F <- function() {
  # clear any existing graphs and plot your graph within the R window
  return("type your written answer here")
}

# Challenge question G should be written in a separate file that has no dependencies on any functions here.