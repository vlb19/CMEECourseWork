#!/usr/bin/env Rscript

name <- "Victoria Blanchard"
preferred_name <- "Viki"
email <- "vlb19@ic.ac.uk"
username <- "vlb19"
personal_speciation_rate <- 0.002 # will be assigned to each person individually in class and should be between 0.002 and 0.007
getwd()

rm(list = ls())
graphics.off()

##########################################
# Question 1 - Calculate species richness
species_richness <- function(community){
  
  # Count number of unique species in the community
  length(unique(community)) 
}

##########################################
# Question 2 - Generate initial state for your simulation community
init_community_max <- function(size){
  
  # Create vector sequence of length 'size'
  seq(size) 
}

##########################################
# Question 3 - Generate alternative initial state for simulation
init_community_min <- function(size){
  
  # Create a vector of length 'size' containing all 1s
  vec <- c(rep(1, size)) 
  return(vec)
}

##########################################
# Question 4 - Choose two random numbers between 1 and max_value
choose_two <- function(max_value){
  
  # From range 1:max_value, sample 2 numbers
  sample(1:max_value, 2) 
}

##########################################
# Question 5 - Perform a single step of a simple neutral model
neutral_step <- function(community){
  
  #store the two numbers generated by the choose_two function
  choices <- choose_two(length(community)) 
  #replace the number indexed by the first choice with the number indexed by the second choice
  community[choices[1]] <- community[choices[2]] 
  
  return(community)
}

##########################################
# Question 6 - Simulate several neutral_steps on a community so that a generation has passed 
neutral_generation <- function(community){
  #randomly round halved odd community sizes up or down
  steps = round(jitter(length(community)/2, amount = 0.1))
  for (i in 1:steps){
    # perform a neutral step on the community x/2 number of times
    community <- neutral_step(community) 
  }
  return(community)
}

##########################################
# Question 7 - run neutral theory simulation for duration number of generations
neutral_time_series <- function(community,duration)  {
  # Set empty richness vector
  richness <- c(species_richness(community)) 
  
  # For each generation run neutral_generation on the community
  for (generation in 1:duration) {
    community <- neutral_generation(community)
    r = species_richness(community)
    richness <- c(richness, r)
  } 
  
  # return species richness of the final community
  return(richness)
}


##########################################
# Question 9 - Perform a step of a neutral model with speciation
neutral_step_speciation <- function(community,speciation_rate)  {
  newspecies <- runif(1) # generate a random number between 0 and 1
  
  # if the random selection is above the speciation rate run the neutral step
  if (newspecies > speciation_rate) {
    community <- neutral_step (community)
    
    # otherwise replace an individual with a new species
  } else {
    #store the two numbers generated by the choose_two function
    choices <- choose_two(length(community)) 
    #replace the number indexed with new species ID (maximum number in the community and adding one)
    community[choices[1]] <- max(community)+1
  }
  return(community)                                                      
}

##########################################
# Question 10
neutral_generation_speciation <- function(community,speciation_rate)  {
  #randomly round halved odd community sizes up or down
  steps = round(jitter(length(community)/2, amount = 0.1))
  for (i in 1:steps){
    # perform a neutral step on the community x/2 number of times
    community <- neutral_step_speciation(community,speciation_rate)
  }
  
  return(community)
}

##########################################
# Question 11
neutral_time_series_speciation <- function(community,speciation_rate,duration)  {
  # Set empty richness vector
  richness <- c(species_richness(community)) 
  
  # For each generation run neutral_generation on the community
  for (generation in 1:duration) {
    community <- neutral_generation_speciation(community, speciation_rate)
    r = species_richness(community)
    richness <- c(richness, r)
  } 
  
  # return species richness of the final community
  return(richness)
}


##########################################
# Question 13 - tell you what the species abundances are
species_abundance <- function(community)  {
  table <- table(community) # store unique identities in first row and counts in second row
  sort(table, decreasing = TRUE) # sort by decreasing abundance of each species
  
}

##########################################
# Question 14
octaves <- function(abundance_vector) {
  # Take a log2 value of the abundance vector
  # Add 1 to this to account for the presence of zeros
  # Round to the lower integer 
  # Bin these values
  tabulate(floor(log2(abundance_vector))+1)
}

##########################################
# Question 15
sum_vect <- function(x, y) {
  # sum two vectors (x and y) after making both vectors
  # the same length
  diff <- length(x)-length(y)
  if (diff > 0) {
    y <- c(y, rep(0, abs(diff))) }
  if (diff < 0) {
    x <- c(x, rep(0, abs(diff))) }
  vector_sum <- x + y
  return(vector_sum)
}

##########################################
# Question 17
cluster_run <- function(speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, output_file_name)  {
  # Initialise community with size given by the input 'size' and minimal diversity
  community <- init_community_min(size)
  # Set counter to zero 
  counter = 0
  
  #save start time and current times as vectors in minutes
  start_time <- proc.time()[3]/60
  current_time <- proc.time()[3]/60
  
  #Apply neutral generations for a predefined amount of time (wall_time)
  while ((current_time-start_time) < wall_time) {
    
    #Apply neutral generations to community
    richness <- neutral_generation_speciation(community, speciation_rate)
    #Record species abundance at the first time step
    SpeciesAbundance <- list(octaves(species_abundance(richness)))
    
    #Run neutral model over the burn-period (burn_in_generations)
    for (generation in 1:burn_in_generations){
      #Record number of generations in the burn in
      counter = counter+1
      
      #Store the species richness at intervals of interval_rich
      if (generation %% interval_rich == 0){
        richness <- neutral_generation_speciation(richness, speciation_rate)
      }
      # Store speices abundances during the burn-in period as octaves 
      # Every interval_oct generations
      if (generation %% interval_oct == 0){
        SpeciesAbundance[length(SpeciesAbundance)+1] <- list(octaves(species_abundance(richness)))
      }
      
      #Record the species abundances as octaves every interval_oct generations
      #outside of the burn-in period
      if (generation %% interval_oct == 0){
        richness <- neutral_generation_speciation(community, speciation_rate)
        SpeciesAbundance[length(SpeciesAbundance)+1] <- list(octaves(species_abundance(richness)))
      }
      current_time <- proc.time()[3]/60
    }
  }
  #Save data to rda file 
  save(counter, SpeciesAbundance,richness,speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, file = output_file_name)
  
}
########################################################
#Question 18
# Read in job number from the cluster
iter <- as.numeric(Sys.getenv("PBS_ARRAY_INDEX"))

# Create local test iter
#iter <- 27

# Create the seed number
set.seed(iter)
# Select the correct iter for community in each parallel simulation 
# based on the iter of iter 
if (1 <= iter & iter <= 25){
  size = 500
} 
if (26 <= iter & iter <= 50){
  size = 1000
} 
if (51 <= iter & iter <= 75){
  size = 2500
} 

if (76 <= iter & iter <= 100){
  size = 5000
} else {print("Sizing was wrong")}

# Set a wall time of 11.5 hours for all your jobs
wall_time = 0.5

#Set the other starting conditions
speciation_rate = 0.00585
interval_rich = 1
interval_oct = size/10
burn_in_generations = 8*size

# Add leading zeros to iter if it is less than three digits long to tidy up the file name
itername <- sprintf("_%03d",iter)

# Create a filename to store results. Set the end of the file name to 
# be iter so files are not overwritted
output_file_name <- paste("NR", itername, ".rda", sep = "")
# Call the function cluster_run to do the simulation 
cluster_run (speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, output_file_name)







