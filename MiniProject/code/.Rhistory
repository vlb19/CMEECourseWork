}
# Find the minimum AIC for the table
minAIC <- min(TestOptimum[,4], na.rm = T)
# Append a and h values to the table of optimised starting values
OptStartValueTable[i,1:4] <- c(data2fit$ID[1],
TestOptimum[which(TestOptimum[4] == minAIC),1],
TestOptimum[which(TestOptimum[4] == minAIC),2],
TestOptimum[which(TestOptimum[4] == minAIC),3])
}
)
Plotting <- function(i, datatry) {
png(paste('Models_for_ID#', OptStartValueTable[i,1], sep = ""))
# Save x values into a variable
Lengths <- seq(min(datatry$ResDensity),max(datatry$ResDensity))
# Predict curves from data
Predic2PlotQua <- predict.lm(QuaFit, data.frame(ResDensity = Lengths))
Predic2PlotCub <- predict.lm(CubFit, data.frame(ResDensity = Lengths))
Predic2PlotHol <- HollingII(Lengths,coef(HolFit)["a"],coef(HolFit)["h"])
Predic2PlotGen <- GenMod(Lengths,coef(GenFit)["a"],coef(GenFit)["h"], coef(GenFit)["q"])
# Plot raw data points
plot(datatry$ResDensity, datatry$N_TraitValue,
xlab = "Resource Density", ylab = "Consumption rate")
title(main = c("Model curves for ID number: ", OptStartValueTable[i,1]))
legend("bottomright", "models", c("Quadratic \n", "Cubic \n", "Holling II \n", "Generalised \nHolling Model"), border = "o",
col = colours, cex = 0.8)
# Create vector of colour options
colours = c('red', 'orange', 'green', 'blue')
lines(Lengths, Predic2PlotQua, col = colours[1], lwd = 1.5)
lines(Lengths, Predic2PlotCub, col = colours[2], lwd = 1.5)
lines(Lengths, Predic2PlotGen, col = colours[3], lwd = 1.5)
lines(Lengths, Predic2PlotHol, col = colours[4], lwd = 1.5)
dev.off()
}
MergedData <- merge(NestedData,Covariates, by = "ID")
modelvec2<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=rep(NA),
"AIC"=rep(NA),
"BIC"=rep(NA))
OptFitsSummary <- data.frame("ID" = StartValueTable[1],
"a_value" = OptStartValueTable[2],
"h_value" = OptStartValueTable[3],
"q_value" = OptStartValueTable[4],
"BestModelAIC" = rep(NA),
"BestAIC" = rep(NA),
"BestModelBIC" = rep(NA),
"BestBIC" = rep(NA),
stringsAsFactors = TRUE)
for (i in 1:length(OptStartValueTable[, 1])){
# Optimise the starting values
# Generate starting values for the Holling models
a <- OptStartValueTable[i, 2]
h <- OptStartValueTable[i, 3]
q <- OptStartValueTable[i, 4]
# Subset data for a particular ID
datatry <- MergedData$data[[i]]
# Create temporary dataframe to hold model AICs
modelvec<-c("PowFit","QuaFit","GenFit", "CubFit")
modelvec<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=modelvec,
"AIC"=rep(NA),
"BIC"=rep(NA))
# Populate dataframe with other factors
modelvec[1:4,1] <- OptStartValueTable[i,1]
modelvec[1:4,2] <- MergedData$Habitat[[i]]
modelvec[1:4,3] <- MergedData$Res_MovementDimensionality[[i]]
modelvec[1:4,4] <- MergedData$Con_MovementDimensionality[[i]]
### Fit models
# Phenomenological quadratic model
QuaFit <- try(lm(N_TraitValue  ~ poly(ResDensity,2),
data = datatry), silent = T)
# Cubic polynomial model
CubFit <- try(lm(N_TraitValue ~ poly(ResDensity,3),
data = datatry), silent = T)
# Holling II model
HolFit <- try(nlsLM(N_TraitValue ~ HollingII(datatry$ResDensity, a, h),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Generalised Holling model
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(datatry$ResDensity, a, h, q),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Phenomenological quadratic model
modelvec[1, 6] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), AIC(QuaFit))
# Cubic polynomial model
modelvec[2, 6] <- ifelse(class(CubFit) == "try-error", rep(NA,1), AIC(CubFit))
# Holling II model
modelvec[3, 6] <- ifelse(class(HolFit) == "try-error", rep(NA,1), AIC(HolFit))
# Generalised Holling model
modelvec[4, 6] <- ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit))
modelvec[1, 7] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), BIC(QuaFit))
# Cubic polynomial model
modelvec[2, 7] <- ifelse(class(CubFit) == "try-error", rep(NA,1), BIC(CubFit))
# Holling II model
modelvec[3, 7] <- ifelse(class(HolFit) == "try-error", rep(NA,1), BIC(HolFit))
# Generalised Holling model
modelvec[4, 7] <- ifelse(class(GenFit) == "try-error", rep(NA,1), BIC(GenFit))
modelvec2 <- bind_rows(modelvec2, modelvec)
# Store the model with the best AIC and the model with the best BIC in the final table
OptFitsSummary[i, 5:8] <- BestAICandBIC(QuaFit, CubFit, HolFit, GenFit)
# Generate plots for each model for each ID
#ifelse(is.na(modelvec), print("NA values present for this ID. No plot generated"),Plotting(i, datatry))
}
# Remove the top row of the modelvec2 dataframe
modelvec2 <- modelvec2[-1,]
ModelFits %>% group_by(ModelFits$Best_AIC_Model) %>% summarise(count=n())
OptFitsSummary %>% group_by(OptFitsSummary$BestModelAIC) %>% summarise(count=n())
# Add in covariate data for analysis
MergedOptTable <- merge(OptFitsSummary,Covariates)
# Add in a column describing if the model is mechanistic or phenomenological
MergedOptTable$MecOrPhen <- ifelse(grepl("3|4", MergedOptTable$BestModelAIC), "Mechanistic", "Phenomenological")
# Remove NA values from modelvec2
modelvec2 <- na.omit(modelvec2)
write.csv(MergedOptTable, file = "../data/OptimisedFitSummary.csv")
write.csv(modelvec2, file = "../data/AnalysisTable.csv")
iters = 10
OptStartValueTable <- data.frame("ID" = NestedData$ID,
"a_value" = rep(NA),
"h_value"= rep(NA),
"q_value"= rep(NA))
suppressWarnings(
for (i in 1:length(OptStartValueTable$ID)){
# Subset data for a single ID
data2fit <- NestedData[i,]
# Retrieve initial start value estimates
a = data2fit[,3]
h = data2fit[,4]
q = 0
# Save data for particular ID into a variable
data2try <- data2fit$data[[1]]
# Generate a potential starting values from initial estimates
avalues <- c(a, rnorm(iters, a, 5), runif(iters, min = -1, max = 1))
hvalues <- c(h, rnorm(iters, h, 5), runif(iters, min = -1, max = 1))
qvalues <- c(q, rnorm(iters, q, 5), runif(iters, min = -2, max = 2))
# Initialise empty data frame to store potential starting values
TestOptimum <- data.frame("avalues" = rep(NA),
"hvalues" = rep(NA),
"qvalues" = rep(NA),
"AIC" = rep(NA))
# Sample initial start parameters to find best starting values
for (k in 1:(iters*5)){
GenStarta <- avalues[k]
GenStarth <- sample(hvalues,1)
GenStartq <- sample(qvalues,1)
# try to fit the general functional response model to every
# starting value in the list
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(data2try$ResDensity, a, h, q),
data = data2try, start = list(a = GenStarta, h = GenStarth, q = GenStartq)), silent = T)
# add test values to table
TestOptimum[k,1:4] <- c(GenStarta, GenStarth, GenStartq, ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit)))
}
# Find the minimum AIC for the table
minAIC <- min(TestOptimum[,4], na.rm = T)
# Append a and h values to the table of optimised starting values
OptStartValueTable[i,1:4] <- c(data2fit$ID[1],
TestOptimum[which(TestOptimum[4] == minAIC),1],
TestOptimum[which(TestOptimum[4] == minAIC),2],
TestOptimum[which(TestOptimum[4] == minAIC),3])
}
)
Plotting <- function(i, datatry) {
png(paste('Models_for_ID#', OptStartValueTable[i,1], sep = ""))
# Save x values into a variable
Lengths <- seq(min(datatry$ResDensity),max(datatry$ResDensity))
# Predict curves from data
Predic2PlotQua <- predict.lm(QuaFit, data.frame(ResDensity = Lengths))
Predic2PlotCub <- predict.lm(CubFit, data.frame(ResDensity = Lengths))
Predic2PlotHol <- HollingII(Lengths,coef(HolFit)["a"],coef(HolFit)["h"])
Predic2PlotGen <- GenMod(Lengths,coef(GenFit)["a"],coef(GenFit)["h"], coef(GenFit)["q"])
# Plot raw data points
plot(datatry$ResDensity, datatry$N_TraitValue,
xlab = "Resource Density", ylab = "Consumption rate")
title(main = c("Model curves for ID number: ", OptStartValueTable[i,1]))
legend("bottomright", "models", c("Quadratic \n", "Cubic \n", "Holling II \n", "Generalised \nHolling Model"), border = "o",
col = colours, cex = 0.8)
# Create vector of colour options
colours = c('red', 'orange', 'green', 'blue')
lines(Lengths, Predic2PlotQua, col = colours[1], lwd = 1.5)
lines(Lengths, Predic2PlotCub, col = colours[2], lwd = 1.5)
lines(Lengths, Predic2PlotGen, col = colours[3], lwd = 1.5)
lines(Lengths, Predic2PlotHol, col = colours[4], lwd = 1.5)
dev.off()
}
MergedData <- merge(NestedData,Covariates, by = "ID")
modelvec2<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=rep(NA),
"AIC"=rep(NA),
"BIC"=rep(NA))
OptFitsSummary <- data.frame("ID" = StartValueTable[1],
"a_value" = OptStartValueTable[2],
"h_value" = OptStartValueTable[3],
"q_value" = OptStartValueTable[4],
"BestModelAIC" = rep(NA),
"BestAIC" = rep(NA),
"BestModelBIC" = rep(NA),
"BestBIC" = rep(NA),
stringsAsFactors = TRUE)
for (i in 1:length(OptStartValueTable[, 1])){
# Optimise the starting values
# Generate starting values for the Holling models
a <- OptStartValueTable[i, 2]
h <- OptStartValueTable[i, 3]
q <- OptStartValueTable[i, 4]
# Subset data for a particular ID
datatry <- MergedData$data[[i]]
# Create temporary dataframe to hold model AICs
modelvec<-c("PowFit","QuaFit","GenFit", "CubFit")
modelvec<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=modelvec,
"AIC"=rep(NA),
"BIC"=rep(NA))
# Populate dataframe with other factors
modelvec[1:4,1] <- OptStartValueTable[i,1]
modelvec[1:4,2] <- MergedData$Habitat[[i]]
modelvec[1:4,3] <- MergedData$Res_MovementDimensionality[[i]]
modelvec[1:4,4] <- MergedData$Con_MovementDimensionality[[i]]
### Fit models
# Phenomenological quadratic model
QuaFit <- try(lm(N_TraitValue  ~ poly(ResDensity,2),
data = datatry), silent = T)
# Cubic polynomial model
CubFit <- try(lm(N_TraitValue ~ poly(ResDensity,3),
data = datatry), silent = T)
# Holling II model
HolFit <- try(nlsLM(N_TraitValue ~ HollingII(datatry$ResDensity, a, h),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Generalised Holling model
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(datatry$ResDensity, a, h, q),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Phenomenological quadratic model
modelvec[1, 6] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), AIC(QuaFit))
# Cubic polynomial model
modelvec[2, 6] <- ifelse(class(CubFit) == "try-error", rep(NA,1), AIC(CubFit))
# Holling II model
modelvec[3, 6] <- ifelse(class(HolFit) == "try-error", rep(NA,1), AIC(HolFit))
# Generalised Holling model
modelvec[4, 6] <- ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit))
modelvec[1, 7] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), BIC(QuaFit))
# Cubic polynomial model
modelvec[2, 7] <- ifelse(class(CubFit) == "try-error", rep(NA,1), BIC(CubFit))
# Holling II model
modelvec[3, 7] <- ifelse(class(HolFit) == "try-error", rep(NA,1), BIC(HolFit))
# Generalised Holling model
modelvec[4, 7] <- ifelse(class(GenFit) == "try-error", rep(NA,1), BIC(GenFit))
modelvec2 <- bind_rows(modelvec2, modelvec)
# Store the model with the best AIC and the model with the best BIC in the final table
OptFitsSummary[i, 5:8] <- BestAICandBIC(QuaFit, CubFit, HolFit, GenFit)
# Generate plots for each model for each ID
#ifelse(is.na(modelvec), print("NA values present for this ID. No plot generated"),Plotting(i, datatry))
}
# Remove the top row of the modelvec2 dataframe
modelvec2 <- modelvec2[-1,]
ModelFits %>% group_by(ModelFits$Best_AIC_Model) %>% summarise(count=n())
OptFitsSummary %>% group_by(OptFitsSummary$BestModelAIC) %>% summarise(count=n())
# Add in covariate data for analysis
MergedOptTable <- merge(OptFitsSummary,Covariates)
# Add in a column describing if the model is mechanistic or phenomenological
MergedOptTable$MecOrPhen <- ifelse(grepl("3|4", MergedOptTable$BestModelAIC), "Mechanistic", "Phenomenological")
# Remove NA values from modelvec2
modelvec2 <- na.omit(modelvec2)
write.csv(MergedOptTable, file = "../data/OptimisedFitSummary.csv")
write.csv(modelvec2, file = "../data/AnalysisTable.csv")
View(modelvec2)
View(modelvec)
View(MergedData$Habitat)
# Generate starting values for the Holling models
a <- OptStartValueTable[i, 2]
h <- OptStartValueTable[i, 3]
q <- OptStartValueTable[i, 4]
# Subset data for a particular ID
datatry <- MergedData$data[[i]]
# Create temporary dataframe to hold model AICs
modelvec<-c("PowFit","QuaFit","GenFit", "CubFit")
modelvec<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=modelvec,
"AIC"=rep(NA),
"BIC"=rep(NA))
# Populate dataframe with other factors
modelvec[1:4,1] <- OptStartValueTable[i,1]
modelvec[1:4,2] <- as.character(MergedData$Habitat[[i]])
modelvec[1:4,3] <- MergedData$Res_MovementDimensionality[[i]]
modelvec[1:4,4] <- MergedData$Con_MovementDimensionality[[i]]
View(modelvec)
### Fit models
# Phenomenological quadratic model
QuaFit <- try(lm(N_TraitValue  ~ poly(ResDensity,2),
data = datatry), silent = T)
# Cubic polynomial model
CubFit <- try(lm(N_TraitValue ~ poly(ResDensity,3),
data = datatry), silent = T)
# Holling II model
HolFit <- try(nlsLM(N_TraitValue ~ HollingII(datatry$ResDensity, a, h),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Generalised Holling model
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(datatry$ResDensity, a, h, q),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Phenomenological quadratic model
modelvec[1, 6] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), AIC(QuaFit))
# Cubic polynomial model
modelvec[2, 6] <- ifelse(class(CubFit) == "try-error", rep(NA,1), AIC(CubFit))
# Holling II model
modelvec[3, 6] <- ifelse(class(HolFit) == "try-error", rep(NA,1), AIC(HolFit))
# Generalised Holling model
modelvec[4, 6] <- ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit))
modelvec[1, 7] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), BIC(QuaFit))
# Cubic polynomial model
modelvec[2, 7] <- ifelse(class(CubFit) == "try-error", rep(NA,1), BIC(CubFit))
# Holling II model
modelvec[3, 7] <- ifelse(class(HolFit) == "try-error", rep(NA,1), BIC(HolFit))
# Generalised Holling model
modelvec[4, 7] <- ifelse(class(GenFit) == "try-error", rep(NA,1), BIC(GenFit))
modelvec2 <- bind_rows(modelvec2, modelvec)
# Store the model with the best AIC and the model with the best BIC in the final table
OptFitsSummary[i, 5:8] <- BestAICandBIC(QuaFit, CubFit, HolFit, GenFit)
# Generate plots for each model for each ID
#ifelse(is.na(modelvec), print("NA values present for this ID. No plot generated"),Plotting(i, datatry))
}
# Remove the top row of the modelvec2 dataframe
modelvec2 <- modelvec2[-1,]
ModelFits %>% group_by(ModelFits$Best_AIC_Model) %>% summarise(count=n())
OptFitsSummary %>% group_by(OptFitsSummary$BestModelAIC) %>% summarise(count=n())
# Add in covariate data for analysis
MergedOptTable <- merge(OptFitsSummary,Covariates)
# Add in a column describing if the model is mechanistic or phenomenological
MergedOptTable$MecOrPhen <- ifelse(grepl("3|4", MergedOptTable$BestModelAIC), "Mechanistic", "Phenomenological")
# Append a and h values to the table of optimised starting values
OptStartValueTable[i,1:4] <- c(data2fit$ID[1],
TestOptimum[which(TestOptimum[4] == minAIC),1],
TestOptimum[which(TestOptimum[4] == minAIC),2],
TestOptimum[which(TestOptimum[4] == minAIC),3])
suppressWarnings(
for (i in 1:length(OptStartValueTable$ID)){
# Subset data for a single ID
data2fit <- NestedData[i,]
# Retrieve initial start value estimates
a = data2fit[,3]
h = data2fit[,4]
q = 0
# Save data for particular ID into a variable
data2try <- data2fit$data[[1]]
# Generate a potential starting values from initial estimates
avalues <- c(a, rnorm(iters, a, 5), runif(iters, min = -1, max = 1))
hvalues <- c(h, rnorm(iters, h, 5), runif(iters, min = -1, max = 1))
qvalues <- c(q, rnorm(iters, q, 5), runif(iters, min = -2, max = 2))
# Initialise empty data frame to store potential starting values
TestOptimum <- data.frame("avalues" = rep(NA),
"hvalues" = rep(NA),
"qvalues" = rep(NA),
"AIC" = rep(NA))
# Sample initial start parameters to find best starting values
for (k in 1:(iters*5)){
GenStarta <- avalues[k]
GenStarth <- sample(hvalues,1)
GenStartq <- sample(qvalues,1)
# try to fit the general functional response model to every
# starting value in the list
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(data2try$ResDensity, a, h, q),
data = data2try, start = list(a = GenStarta, h = GenStarth, q = GenStartq)), silent = T)
# add test values to table
TestOptimum[k,1:4] <- c(GenStarta, GenStarth, GenStartq, ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit)))
}
# Find the minimum AIC for the table
minAIC <- min(TestOptimum[,4], na.rm = T)
# Append a and h values to the table of optimised starting values
OptStartValueTable[i,1:4] <- c(data2fit$ID[1],
TestOptimum[which(TestOptimum[4] == minAIC),1],
TestOptimum[which(TestOptimum[4] == minAIC),2],
TestOptimum[which(TestOptimum[4] == minAIC),3])
}
)
Plotting <- function(i, datatry) {
png(paste('Models_for_ID#', OptStartValueTable[i,1], sep = ""))
# Save x values into a variable
Lengths <- seq(min(datatry$ResDensity),max(datatry$ResDensity))
# Predict curves from data
Predic2PlotQua <- predict.lm(QuaFit, data.frame(ResDensity = Lengths))
Predic2PlotCub <- predict.lm(CubFit, data.frame(ResDensity = Lengths))
Predic2PlotHol <- HollingII(Lengths,coef(HolFit)["a"],coef(HolFit)["h"])
Predic2PlotGen <- GenMod(Lengths,coef(GenFit)["a"],coef(GenFit)["h"], coef(GenFit)["q"])
# Plot raw data points
plot(datatry$ResDensity, datatry$N_TraitValue,
xlab = "Resource Density", ylab = "Consumption rate")
title(main = c("Model curves for ID number: ", OptStartValueTable[i,1]))
legend("bottomright", "models", c("Quadratic \n", "Cubic \n", "Holling II \n", "Generalised \nHolling Model"), border = "o",
col = colours, cex = 0.8)
# Create vector of colour options
colours = c('red', 'orange', 'green', 'blue')
lines(Lengths, Predic2PlotQua, col = colours[1], lwd = 1.5)
lines(Lengths, Predic2PlotCub, col = colours[2], lwd = 1.5)
lines(Lengths, Predic2PlotGen, col = colours[3], lwd = 1.5)
lines(Lengths, Predic2PlotHol, col = colours[4], lwd = 1.5)
dev.off()
}
MergedData <- merge(NestedData,Covariates, by = "ID")
modelvec2<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=rep(NA),
"AIC"=rep(NA),
"BIC"=rep(NA))
OptFitsSummary <- data.frame("ID" = StartValueTable[1],
"a_value" = OptStartValueTable[2],
"h_value" = OptStartValueTable[3],
"q_value" = OptStartValueTable[4],
"BestModelAIC" = rep(NA),
"BestAIC" = rep(NA),
"BestModelBIC" = rep(NA),
"BestBIC" = rep(NA),
stringsAsFactors = TRUE)
for (i in 1:length(OptStartValueTable[, 1])){
# Optimise the starting values
# Generate starting values for the Holling models
a <- OptStartValueTable[i, 2]
h <- OptStartValueTable[i, 3]
q <- OptStartValueTable[i, 4]
# Subset data for a particular ID
datatry <- MergedData$data[[i]]
# Create temporary dataframe to hold model AICs
modelvec<-c("PowFit","QuaFit","GenFit", "CubFit")
modelvec<-data.frame("ID "=rep(NA),
"Habitat"=rep(NA),
"ResDimension"=rep(NA),
"ConDimension"=rep(NA),
"Model"=modelvec,
"AIC"=rep(NA),
"BIC"=rep(NA))
# Populate dataframe with other factors
modelvec[1:4,1] <- OptStartValueTable[i,1]
modelvec[1:4,2] <- as.character(MergedData$Habitat[[i]])
modelvec[1:4,3] <- MergedData$Res_MovementDimensionality[[i]]
modelvec[1:4,4] <- MergedData$Con_MovementDimensionality[[i]]
### Fit models
# Phenomenological quadratic model
QuaFit <- try(lm(N_TraitValue  ~ poly(ResDensity,2),
data = datatry), silent = T)
# Cubic polynomial model
CubFit <- try(lm(N_TraitValue ~ poly(ResDensity,3),
data = datatry), silent = T)
# Holling II model
HolFit <- try(nlsLM(N_TraitValue ~ HollingII(datatry$ResDensity, a, h),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Generalised Holling model
GenFit <- try(nlsLM(N_TraitValue ~ GenMod(datatry$ResDensity, a, h, q),
data = datatry, start = list(a=a, h=h)),
silent = T)
# Phenomenological quadratic model
modelvec[1, 6] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), AIC(QuaFit))
# Cubic polynomial model
modelvec[2, 6] <- ifelse(class(CubFit) == "try-error", rep(NA,1), AIC(CubFit))
# Holling II model
modelvec[3, 6] <- ifelse(class(HolFit) == "try-error", rep(NA,1), AIC(HolFit))
# Generalised Holling model
modelvec[4, 6] <- ifelse(class(GenFit) == "try-error", rep(NA,1), AIC(GenFit))
modelvec[1, 7] <- ifelse(class(QuaFit) == "try-error", rep(NA,1), BIC(QuaFit))
# Cubic polynomial model
modelvec[2, 7] <- ifelse(class(CubFit) == "try-error", rep(NA,1), BIC(CubFit))
# Holling II model
modelvec[3, 7] <- ifelse(class(HolFit) == "try-error", rep(NA,1), BIC(HolFit))
# Generalised Holling model
modelvec[4, 7] <- ifelse(class(GenFit) == "try-error", rep(NA,1), BIC(GenFit))
modelvec2 <- bind_rows(modelvec2, modelvec)
# Store the model with the best AIC and the model with the best BIC in the final table
OptFitsSummary[i, 5:8] <- BestAICandBIC(QuaFit, CubFit, HolFit, GenFit)
# Generate plots for each model for each ID
#ifelse(is.na(modelvec), print("NA values present for this ID. No plot generated"),Plotting(i, datatry))
}
# Remove the top row of the modelvec2 dataframe
modelvec2 <- modelvec2[-1,]
ModelFits %>% group_by(ModelFits$Best_AIC_Model) %>% summarise(count=n())
OptFitsSummary %>% group_by(OptFitsSummary$BestModelAIC) %>% summarise(count=n())
# Add in covariate data for analysis
MergedOptTable <- merge(OptFitsSummary,Covariates)
# Add in a column describing if the model is mechanistic or phenomenological
MergedOptTable$MecOrPhen <- ifelse(grepl("3|4", MergedOptTable$BestModelAIC), "Mechanistic", "Phenomenological")
# Remove NA values from modelvec2
modelvec2 <- na.omit(modelvec2)
write.csv(MergedOptTable, file = "../data/OptimisedFitSummary.csv")
write.csv(modelvec2, file = "../data/AnalysisTable.csv")
View(MergedOptTable)
# Add in covariate data for analysis
MergedOptTable <- merge(OptFitsSummary,Covariates)
# Add in a column describing if the model is mechanistic or phenomenological
MergedOptTable$MecOrPhen <- ifelse(grepl("HolFit|GenFit", MergedOptTable$BestModelAIC), "Mechanistic", "Phenomenological")
# Remove NA values from modelvec2
modelvec2 <- na.omit(modelvec2)
View(MergedOptTable)
source('~/Documents/CMEECourseWork/MiniProject/code/NLLS_Fitting_Script5.R', echo=TRUE)
source('~/Documents/CMEECourseWork/MiniProject/code/NLLS_Fitting_Script5.R', echo=TRUE)
# Remove NA values from modelvec2
modelvec2 <- na.omit(modelvec2)
View(modelvec2)
source('~/Documents/CMEECourseWork/MiniProject/code/NLLS_Fitting_Script5.R', echo=TRUE)
