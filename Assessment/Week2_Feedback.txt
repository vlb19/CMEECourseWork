Starting weekly assessment for Victoria, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 20.55 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week9, Week4, .git, SeminarDiary, Week3, Project, MiniProject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.bbl
*.blg
*.pdf
*.gz
*.rda
results
Week6/genomics_and_bioinformatics
Project/ProjectProposal
Project/Practice_Genetics
.png
__pycache__
. -size +50M
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository

Week 1 - Unix and Bash tutorials

Week 2 - Introduction to Python

Week 3 - Introduction to R

Week 4 - Learning statistics

Week 5 - Putting statistics into practice

Week 6 - Genetics practicals

Week 7 - Advanced Python

Week 9 - HPC Week 

MiniProject - Ongoing miniproject on Functional Responses

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week9

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: code, sandbox, data, results

Found the following files: readme.md

Checking for readme file in weekly directory...

Found README in parent directory, named: readme.md

Printing contents of readme.md:
**********************************************************************
# Week 2 readme file

## Wee2 folder
* code
* data
* results
* sandbox
* readme.md

### Code Folder

#### align_seqs.py
* no user input required
* inputs sequences saved in data file
* aligns two sequences and assigns them a score
* saves best alignment and best alignment score to text file in results

#### align_seqs_better.py
* imports two sequences from either user defined files or specified files in the fasta folder
* aligns two sequences and assigns them a score
* saves best alignment score and best corresponding alignments to text file in results

#### align_seqs_fasta.py
* imports two sequences from either user defined files or specified files in the fasta folder
* aligns two sequences and assigns them a score
* saves last alignment with best alignment score and the score to text file in results

#### basic_io1.py
* Requires no user input 
* Imports data from sandbox 
* prints data file then prints every other line from data file

#### basic_csv.py
* Requires no user input 
* Imports csv
* Imports csv data from data folder 
* Writes data from csv to a differents csv 

#### basic_io2.py
* Requires no user input
* Imports string data from sandbox
* Writes contents of datafile from sandbox to new file

#### basic_io3.py
* Requires no user input
* Imports pickle 
* Imports string data from sanbox
* Pickle.dumps imported string data then pickle loads it 

#### boilerplate.py
* Requires no user input
* Returns "this is a boilerplate"

#### cfexercises1.py
* Requires no user input 
* Returns various values and serves as the base code for cfexercises2

#### cfexercises2.py
* Requires user input of an integer
* Runs cfexercises1.py code on user input

#### control_flow.py
* Requires user input of one integer
* Returns prodcuts of various functions if input is there or uses internally stored values if there is no input

#### debugme.py
* Requires no user input 
* Returns an error when run

#### dictionary.py
* Requires no user input 
* Creates dictionary of taxa with species as first column and order as second
* Prints taxa dictionary grouped by order 

#### lc1.py
* Requires no user input
* Creates dictionary of bird species name, common name, and weights
* Prints each column separately twice 

#### lc2.py
* Requires no user input 
* Vector created with Month and total rainfall 
* Returns list of months where rainfall exceeded 100mm and another with months less than 50mm and does this twice

#### loops.py
* Requires no user input 
* Prints several outputs for finite loops before printing "Geronimo" from an infinite loop

#### oaks.py
* Requires no user input
* Returns whether each value in the dictionary is an oak or not

#### oaks_debugme.py
* Requires user string input
* Returns whether user input is defined as an oak

#### scope.py 
* Requires no user input 
* Changes the values of global and local variables then prints those new values

#### sysargv.py
* Requires user input of one or more arguments
* Prints the arguments and the number of arguments

#### test_control_flow.py
* No input required
* Runs doctest on code from control_flow

#### test_control_flow.pyc
* Binary file for test_control_flow.py

#### tuple.py
* No input required 
* Re-orders dictionary by species then common name 

#### using_name.py
* No input required 
* Prints one output if run from command line and another if imported as a module

### Data Folder 
* bodymass.csv 
* sequences.csv
* testcsv.csv
* TestOaksData.csv
* **fasta** folder
    * 407228326.fasta
    * 407228412.fasta
    * E.coli.fasta

### Results Folder
Empty

**Sandbox contents ignored************************************************************************

Found following files in results directory: JustOaksData.csv, best_fasta_alignment.txt, best_alignment.txt, best_fasta_alignments.txt, .gitignore...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 23 code files: basic.io1.py, lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

Found the following extra files: 
0.5 pt deducted per extra file

Current Points = 100.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file basic.io1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Read in a text file and print the contents """

#################
# FILE INPUT
#################
# Open a file for reading 
f = open('../sandbox/test.txt','r' )
#use "implicit" for loop:
# if the object is a file, python will cycle over lines 
for line in f:
    print(line)

#close the file 
f.close()

#Same example, skip blank lines 
f = open('../sandbox/test.txt','r' ) 
for line in f:
    if len(line.strip()) > 0:
        print(line)
f.close()**********************************************************************

Testing basic.io1.py...

basic.io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic.io1.py", line 8, in <module>
    f = open('../sandbox/test.txt','r' )
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Use a list comprehension to create a list of month,
rainfall tuples where the amount of rain was greater than 100 mm.
Then use a list comprehension to create a list of just month names where the
 amount of rain was less than 50 mm. Then do it all again using 
 conventional loops"""

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )


# 1) Create list of month, rainfall tuples where 
# the amount of rain is greater than 100mm

print ("Months where rainfall exceeded 100 mm") #tells the user what to expect
Months_above_100  = [row[0] for row in rainfall if row[1] > 100]
Values_above_100  = [row[1] for row in rainfall if row[1] > 100]
print (Months_above_100 + Values_above_100)

# 2) A a list of just month names where the
# amount of rain was less than 50 mm. 

print ("Months where rainfall was less than 50 mm") #tells the user what to expect
Months_below_50  = [row[0] for row in rainfall if row[1] < 50]
Values_below_50  = [row[1] for row in rainfall if row[1] < 50]
print (Months_below_50 + Values_below_50)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

For_Month_above_100 = [] #creates new empty dictionary
for row in rainfall: #searches each value in rainfall
    if row[1] > 100: #if the second column value is larger than 100
        For_Month_above_100.append(row[0]) #add the corresponding month to the dictionary
        For_Month_above_100.append(row[1]) #and add the rainfall value
print ("Months where rainfall exceeded 100 mm") #tells the user what to expect
print (For_Month_above_100) #prints dictionary 

For_Month_below_50 = []
for row in rainfall:
    if row[1] < 50:
        For_Month_below_50.append(row[0])
        For_Month_below_50.append(row[1])
print ("Months where rainfall was less than 50 mm")
print (For_Month_below_50)
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100.0

Output (only first 500 characters): 

**********************************************************************
Months where rainfall exceeded 100 mm
['JAN', 'FEB', 'AUG', 'NOV', 'DEC', 111.4, 126.1, 140.2, 128.4, 142.2]
Months where rainfall was less than 50 mm
['MAR', 'SEP', 49.9, 27.0]
Months where rainfall exceeded 100 mm
['JAN', 111.4, 'FEB', 126.1, 'AUG', 140.2, 'NOV', 128.4, 'DEC', 142.2]
Months where rainfall was less than 50 mm
['MAR', 49.9, 'SEP', 27.0]

**********************************************************************

Code ran without errors

Time consumed = 0.02582s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" A program that prints different statments 
when called from different programs """ 

__appname__ = '[boilerplate.py]'
__author__ = 'Victoria Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##

import sys #module to interface our program with the operating system 

## constants ##

## functions ## 
def main(argv):
    """Main entry point of the program """
    print("This is a boilerplate") # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)

#What is main(argv)?
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100.0

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03395s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""print modified contents of one csv file to another csv file """

### Imports 
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../data/testcsv.csv','r')

# Read in file and append contents of each row to a temporary tuple
# Print each row preceeded by "The species is"
csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()

# write a file containing only species name and Body mass
f = open('../data/testcsv.csv','r')
g = open('../data/bodymass.csv','w')

# Write a new csv file containing each row
csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100.0

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03160s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

""" Tutorial on for loops, while, and if statements in python """

__appname__ = '[cfexercises2.py]'
__author__ = 'Victoria Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'

### Imports

import sys #module to interface our program with the operating system

# Use system arguments if they are given, otherwise use default values
if len(sys.argv) > 1:
    x = int(sys.argv[1])
    y = int(sys.argv[2])
    z = int(sys.argv[3])
else:
    x = 3
    y = 10
    z = 6

### Functions
def say_hello(x,y):
    for i in range(x,y):
        print('hello')
    
def x_div_3(x):
    for j in range(x):
        if j % 3 == 0:
         print('hello')

def x_div_3or4(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')

def z_not_15(z):
    while z != 15:
        print('hello')
        z = z + 3

def zbelow100(z):
    while z < 100:
        if z == 31:
            for k in range(7):
                print ('hello')
        elif z == 18:
            print ('hello')
        z = z + 1 

# Script

print("Says hello y-x times")
print (say_hello(x,y))
print ("Done!")

print("Says hello x/3 times")
print(x_div_3(x))
print("Done!")

print(x_div_3or4(x))
print("Done!")

print("Says hello while z+3 does not equal 15")
print(z_not_15(z))
print("Done!")

print("Says hello while z is below 100 and fits within the parameters")
print(zbelow100(z))
print("Done!")
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
Says hello y-x times
hello
hello
hello
hello
hello
hello
hello
None
Done!
Says hello x/3 times
hello
None
Done!
None
Done!
Says hello while z+3 does not equal 15
hello
hello
hello
None
Done!
Says hello while z is below 100 and fits within the parameters
hello
hello
hello
hello
hello
hello
hello
hello
None
Done!

**********************************************************************

Code ran without errors

Time consumed = 0.02737s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3


"""Align two user inputted DNA sequences 
and save the best alignments to a csv file"""

__appname__ = 'align_seqs_better.py'
__author__ = 'Viki Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'

#Imports

import os
import sys
import pickle

path = "../data/fasta" # sets the path to the desired directory
os.chdir(path) # sets the directory to the path

def parse_fasta(fastafile): # converts any fasta file to a single
    #string with the header removed
    fastastr = ""
    header = True
    with open(fastafile, "r") as f:
        for row in f:
            if header:
                header = False #skips first line
            else:
                fastastr += row.strip("\n") #strips all new lines
    return fastastr

if len(sys.argv) > 1: #if there are user arguments use them
    seq1 = parse_fasta(sys.argv[1])
    seq2 = parse_fasta(sys.argv[2])
else: #otherwise use the set files
    seq1 = parse_fasta("407228412.fasta")
    seq2 = parse_fasta("407228326.fasta")


# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = {} # Create new empty dictionary for best scores


for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    my_best_align = "." * i + s2 # add i number of "." before adding
    #the sequence which is aligning sequence 2 to seq1 
    if z in my_best_score.keys(): 
        my_best_score[z].append(my_best_align) #append aligments to 
        #dictionary by score
    else:
        my_best_score[z] = [my_best_align]

vals = max(my_best_score.keys()) #store the higest score to vals variable

path = "../../code" #set path to original directory
os.chdir(path) #change to original directory

f = open('../results/best_fasta_alignments.txt','w+') #open new file in 
#results
f.write ("Best Alignment: "+"\n") #heading for document 
for x in my_best_score[vals]:
    f.write(x) # Write every alignment with the best score 
f.write ("\n" + seq2 + "\n") # Write the sequence seq1 is aligned to
f.write ("Best Score: " + "\n" + str(vals)) #write in the best score value
f.close()

print("Sequences aligned!")
**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 96.5

Output (only first 500 characters): 

**********************************************************************
Sequences aligned!

**********************************************************************

Code ran without errors

Time consumed = 3.36119s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" A short python script to populate a dictionary called taxa_dic 
 derived from  taxa so that it maps order names to sets of taxa. 
E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 
 """ 

# Create dictionary of species
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Create empty dictionary and empty list
taxa_dic = {}
order_dict = []

# Add every order to the empty list
for species,order in taxa:
    if order not in order_dict:
        order_dict.append(order)
# add every order as a dictionary key and then add 
# species to their corresponding dictionary key 
    for y in order_dict:
        set_add = set()
        for i in taxa: 
            if i[1] == y:
                set_add.add(i[0])
        taxa_dic[y]=set_add

""" An alternate method """ 
#Create new empty dictionary

taxa_dic = []

### Imports
from collections import defaultdict 

### Script
taxa_dic = defaultdict(list) 
#creates dictionary containing defaultdict and sets 
#the defaultfactory setting to list, meaning it will make a new list for each 
#item encountered for the first time, append that item and then re-run the for loop
#the for loop contained within the function makes a list for each key then the the 
#new list item is appended to the existing key 

for taxas, order in taxa: #identifies the first column as taxa and the second column
    #as order
    taxa_dic[order].append(taxas) #appends taxa values to the corresponding order key


print ("Dictionary of order names and taxa") #tells the user what is happening
print (taxa_dic) #prints the new dictionary
 
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Current Points = 96.5

Output (only first 500 characters): 

**********************************************************************
Dictionary of order names and taxa
defaultdict(<class 'list'>, {'Chiroptera': ['Myotis lucifugus'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci']})

**********************************************************************

Code ran without errors

Time consumed = 0.02632s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Make a bug to debug later """ 

def makeabug(x):
    y = x**4
    z = 0
    y = y/z
    return y

makeabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 94.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugme.py", line 11, in <module>
    makeabug(25)
  File "debugme.py", line 8, in makeabug
    y = y/z
ZeroDivisionError: division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: sysargv.py
# Date: 3 December 2019

""" Demonstrate global and local variables """

# OUTPUT
# Prints global and local variables

#Code block 1

_a_global = 10 # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # also a global variable

def a_function():
    _a_global = 5 # a local variable

    if _a_global >=5: 
        _b_global = _a_global + 5 #also a local variable

    _a_local = 4

    print ("Inside the function, the value of _a_global is ",_a_global)
    print ("Inside the function, the value of _b_global is ", _b_global)
    print ("Inside the function, the value of _a_local is ", _a_local)
    
    return None

a_function()

print ("Outside the function, the value of _a_global is ", _a_global)
print ("Outside the function, the value of _b_global is ", _b_global)

#Code block 2 

_a_global = 10

def a_function():
    _a_local = 4
    
    print("Inside the function, the value of _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)

    return None 

a_function()

print("Outside the function, the value of _a_global is ", _a_global)

#Code block 3

_a_global = 10

print ("Outside the function, the value of _a_global is", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4

    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _a_local is ", _a_local)

    return None

a_function()

print("Outsidee the function, the value of _a_global now is ", _a_global)

#Code block 4

def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()

    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of _a_global in main workspace / namespace is ", _a_global)

_a_global = 10

def a_function():
    
    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()

    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15
Inside the function, the value of _a_local is  4
Inside the function, the value of _a_global is  10
Outside the function, the value of _a_global is  10
Outside the function, the value of _a_global is 10
Inside the function, the value of _a_global 
**********************************************************************

Code ran without errors

Time consumed = 0.02574s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Learning how to open and retrieve pickle dumps """

#######################
# STORING OBJECTS
#######################
# To save an object (even complex) for later use

### Imports 
import pickle

### Script
#Create a dictionary with keys and data
my_dictionary = {"a key":10, "another key":11}

#Open a pickle file and dump dictionary into it
f = open('../sandbox/testp.p','wb')
pickle.dump(my_dictionary,f)
f.close()

## Load the data again from the pickle file
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.03016s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Say hello """ 

# How many times will 'hello' be printed?

for i in range(3, 5):
    print('hello')
print ('done')

for j in range(12):
    if j % 3 == 0:
        print('hello')
print('done')

for j in range(15):
     if j % 5 == 3:
        print (j)
        print('hello1')
     elif j % 4 == 3:
        print (j)
        print('hello2')
print('done')

z = 0
while z != 15:
    print('hello')
    z = z + 3
print('done')

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print ('hello')
    elif z == 18:
        print ('hello')
    z = z + 1
print('done')**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
hello
hello
done
hello
hello
hello
hello
done
3
hello1
7
hello2
8
hello1
11
hello2
13
hello1
done
hello
hello
hello
hello
hello
done
hello
hello
hello
hello
hello
hello
hello
hello
done

**********************************************************************

Code ran without errors

Time consumed = 0.02740s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: tuple.py
# Date: 3 December 2019

""" Birds is a tuple of tuples of length three: latin name, common name, mass.
This is a script to print these on a separate line or output block by species """

# OUTPUT
# Prints latin name, common name, and mass of each individual within the 
# dictionary on a separate line

### Dictionary of birds with latin name, common name, and mass
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

print ("Information on birds in dictionary")

# print each piece of information in a separate output block
for birdinfo in birds:
    print( "The latin name is: ", birdinfo[0])
    print( "The common name is: ", birdinfo[1])
    print( "The average species mass is: ", birdinfo[2], "\n")


**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
Information on birds in dictionary
The latin name is:  Passerculus sandwichensis
The common name is:  Savannah sparrow
The average species mass is:  18.7 

The latin name is:  Delichon urbica
The common name is:  House martin
The average species mass is:  19 

The latin name is:  Junco phaeonotus
The common name is:  Yellow-eyed junco
The average species mass is:  19.5 

The latin name is:  Junco hyemalis
The common name is:  Dark-eyed junco
The average species mass is:  19.6 

The latin name is:
**********************************************************************

Code ran without errors

Time consumed = 0.03285s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. Then do the same using conventional 
# loops """

# Create a new dictionary with species name, common name, and mass
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

### Using list comprehension 

print ("Latin names of birds") #Tells the user what is happening
Latin_Names  = [row[0]for row in birds] #stores the first column of birds into a new dictionary
print (Latin_Names) #prints the new dictionary

print ("Common names of birds")
Common_Names = [row[1]for row in birds]
print (Common_Names)

print ("Mean body mass of each species")
Body_Mass = [row[2]for row in birds]
print (Body_Mass)

### Using conventional loops

For_Latin_Names = [] #creates new empty dictionary
for row in birds: #searches each value in birds
    For_Latin_Names.append(row[0]) #adds the first value of each row to the new dictionary
print ("Latin names of birds") #tells the user what is happening
print (For_Latin_Names) #prints the new dictionary

For_Common_Names = []
for row in birds:
    For_Common_Names.append(row[1])
print ("Common names of birds")
print (For_Common_Names)

For_Body_Mass = []
for row in birds:
    For_Body_Mass.append(row[2])
print ("Mean body mass of each species")
print (For_Body_Mass)
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 90.5

Output (only first 500 characters): 

**********************************************************************
Latin names of birds
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
Common names of birds
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
Mean body mass of each species
[18.7, 19, 19.5, 19.6, 20.2]
Latin names of birds
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
Common names of birds
['Savannah sparrow', 'House martin', 'Ye
**********************************************************************

Code ran without errors

Time consumed = 0.03307s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: oaks_debugme.py
# Date: 3 December 2019

""" Checks whether items in a dictionary are oaks """

# ARGUMENTS
# Requires csv file

# OUTPUT
# Prints "Found an Oak", writes a csv file containing
# only oaks

### Imports ###

import csv
import sys
import doctest
import re

#Define function
def is_an_oak(name):
    """
    Returns True if name starts with 'quercus'
    
    >>> is_an_oak('Fagus sykvatica')
    False
    
    >>> is_an_oak('Quercus cerris')
    True

    >>> is_an_oak('Quercus')
    True

    """
    # match "quercus" with the input name
    if re.match(r'\bquercus\b', name, re.IGNORECASE):
        return True
    else:
        return False


def main(argv): 
    # open data
    f = open('../data/TestOaksData.csv','r')
    line1 = f.readline()
    lines = f.readlines()[0:]

    # open output document
    g = open('../results/JustOaksData.csv','w')
    g.write(line1)
    taxa = csv.reader(lines)
    csvwrite = csv.writer(g)
    oaks = set()

    # test whether each row in taxa contains an oak
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0


if (__name__ == "__main__"):
    status = main(sys.argv)
    doctest.testmod()**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 90.0

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.07145s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: oaks.py
# Date: 3 December 2019

""" Checks whether items in a dictionary are oaks """

# OUTPUT
# Prints "Found an Oak", writes a csv file containing
# only oaks

## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 89.5

Output (only first 500 characters): 

**********************************************************************
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.03163s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Learning how to use for and while loops in python"""

# FOR loops in Python
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops  in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 89.5

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.34347s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: using_name.py
# Date: 25 October 2019

""" Changes output depending on where program is called from """

# OUTPUT
# prints output depending on where the program is called from

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')

**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 89.5

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07109s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#! usr/bin/python3
'''align two DNA sequences'''


# Two example sequences to match

exec(open("../data/sequences.csv").read(),globals())

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

f = open('../results/best_alignment.txt',"w+")
my_best_score = str(my_best_score)
f.write ("Best Alignment: ")
f.write ("\n")
f.write (my_best_align)
f.write ("\n")
f.write ("Best Score: ")
f.write ("\n")
f.write (my_best_score)
f.close()**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more functions, but missing docstrings; .5 pt deducted per missing docstring for function

Current Points = 89.0

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.04587s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" print a list into a txt file separated by newline characters"""

##################
# FILE OUTPUT
##################
# Save the elements of a list to a file 
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i)+'\n') ##Add a new line at the end 

f.close()**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 87.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02926s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: sysargv.py
# Date: 3 December 2019

""" Demonstrate system arguments """

# ARGUMENTS
# system argument required

# OUTPUT
# Prints system argument-dependent strings

### Imports ###

import sys

### Script ###
print("This is the name of the script", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))

**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 87.0

Output (only first 500 characters): 

**********************************************************************
This is the name of the script sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02824s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Align two DNA sequences and save the best alignment 
and best alignment score to a csv file in results folder"""

### Imports
import os
import sys

# Change working directory
path = "../data/fasta"
os.chdir(path)

### Functions

# Parse the fasta file to skip the header then remove newline characters
def parse_fasta(fastafile):
    fastastr = ""
    header = True
    with open(fastafile, "r") as f:
        for row in f:
            if header:
                header = False
            else:
                fastastr += row.strip("\n")
    return fastastr

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Check for system arguments and use default files if there are none
if len(sys.argv) > 1:
    seq1 = parse_fasta(sys.argv[1])
    seq2 = parse_fasta(sys.argv[2])
else: 
    seq1 = parse_fasta("407228412.fasta")
    seq2 = parse_fasta("407228326.fasta")


# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # use * to move the sequences along
        my_best_score = z 

print("Sequences aligned!")

# Change working directory
path = "../../code"
os.chdir(path)

# Save results into text file with proper formatting
f = open('../results/best_fasta_alignment.txt',"w+")
my_best_score = str(my_best_score)
f.write ("Best Alignment: ")
f.write ("\n")
f.write (my_best_align)
f.write ("\n")
f.write (seq2)
f.write ("\n")
f.write ("Best Score: ")
f.write ("\n")
f.write (my_best_score)
f.close()**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 86.0

Output (only first 500 characters): 

**********************************************************************
Sequences aligned!

**********************************************************************

Code ran without errors

Time consumed = 3.39558s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Create a lot of functions with the abilty to 
call them from other programs """ 

__appname__ = '[boilerplate.py]'
__author__ = 'Victoria Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

### Imports

import sys #module to interface our program with the operating system 

### Functions
def even_or_odd(x=0): #if not specified, x should take value 0. 

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if 
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find whether a number x is even or odd."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: #When all other (if, elif) conditions are not met 
        return "No divisor found for %d!" % x #Each function can return a value or a variable
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime. """
    for i in range(2, x): # "range" returns a sequence of integers 
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x, i))
            return False
    print("%d is prime!" % x)
    return True

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range (2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    """Main entry point of the program """
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0


# Makes program able to run from the command line and allows 
# functions to be called from within script in different programs
if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 86.0

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is prime!
True
2 is prime!
3 is prime!
4 is not a prime: 2 is a divisor
5 is prime!
6 is not a prime: 2 is a divisor
7 is prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is prime!
12 is not a prime: 2 is a divisor
13 is prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is not a prime: 2
**********************************************************************

Code ran without errors

Time consumed = 0.02901s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: tuple.py
# Date: 3 December 2019

""" Use some functions to exemplify the use of control statements """

# OUTPUT
# Runs doctests within scripts

### Imports ###

import sys
import doctest # Import the doctest module

### Function definitions ###

def even_or_odd(x=0):
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'

    """
    #Define function to be tested
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### SUPPRESSED BLOCK #######

# def main(argv): 
#     print even_or_odd(22)
#     print even_or_odd(33)
#     return 0

# if (__name__ == "__main__"):
#     status = main(sys.argv)
############################################

doctest.testmod()   # To run with embedded tests
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 85.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06581s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 85.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!