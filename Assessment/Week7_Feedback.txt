Starting weekly assessment for Victoria, Week7

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 20.55 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week9, Week4, .git, SeminarDiary, Week3, Project, MiniProject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.bbl
*.blg
*.pdf
*.gz
*.rda
results
Week6/genomics_and_bioinformatics
Project/ProjectProposal
Project/Practice_Genetics
.png
__pycache__
. -size +50M
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository

Week 1 - Unix and Bash tutorials

Week 2 - Introduction to Python

Week 3 - Introduction to R

Week 4 - Learning statistics

Week 5 - Putting statistics into practice

Week 6 - Genetics practicals

Week 7 - Advanced Python

Week 9 - HPC Week 

MiniProject - Ongoing miniproject on Functional Responses

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week9

The Week7 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK7...

Found the following directories: code, sandbox, data, results

Found the following files: readme.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: readme.txt

Printing contents of readme.txt:
**********************************************************************
Files:

blackbirds.py  
fmr.R   
LV2.py  
MyFirstJupyterNb.ipynb  
Nets.R         
profileme.py  
run_fmr_R.py  
TestR.py  
using_os.py
DrawFW.py      
LV1.py  
LV3.py  
Nets.py                 
profileme2.py  
runLVs.py     
TestR.R   
timeitme.py**********************************************************************

Found following files in results directory: TestR.Rout, fmr_plot.pdf, Nets.svg, LV_model2.pdf, LV_model.pdf, LV2_model.pdf, DrawFW.pdf, TestR_errFile.Rout, QMEENet.svg...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 18 code files: TestR.py, runLVs.py, LV3.py, profileme2.py, timeitme.py, blackbirds.py, Nets.py, TestR.R, profileme.py, fmr.R, MyFirstJupyterNb.ipynb, using_os.py, LV1.py, DrawFW.py, Nets.R, run_fmr_R.py, LV2.py, MyFirstJupyterNb-checkpoint.ipynb

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TestR.py...

File contents are:
**********************************************************************
#!/usr/bin/env python

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: TestR.py
# Date: 25 November 2019
""" Open a Rscript in an R shell within R"""

## Imports
import subprocess


subprocess.Popen("Rscript --verbose TestR.R > ../results/TestR.Rout 2> ../results/TestR_errFile.Rout", shell=True).wait()

subprocess.Popen("Rscript --verbose TestR.R > ../results/TestR.Rout 2> ../results/TestR_errFile.Rout", shell=True).wait()**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.27944s

======================================================================
Inspecting script file runLVs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: runLVs.py
# Date: 25 November 2019

""" A python script that runs the LV python scripts
using inputs from system arguments"""

import timeit
import scipy as sc
import time
import sys
import cProfile

# Import the functions 
from LV1 import dCR_dt as LV1Script 
from LV2 import dCR_dt as LV2Script
from LV3 import LV3_script

# Set parameters
r = float(sys.argv[1]) 
a = float(sys.argv[2])
z = float(sys.argv[3])
e = float(sys.argv[4])

RC0 = sc.array([10,5])

# Record overall running times for the two scripts
start = time.time()
LV1Script(RC0)
print("LV1 Script takes %f s to run." %(time.time()- start))

start = time.time()
LV2Script(RC0)
print("LV2 Script takes %f s to run." %(time.time()- start))

# Display run times of different sections of the code
cProfile.run('LV1Script(RC0)')
cProfile.run('LV2Script(RC0)')

**********************************************************************

Testing runLVs.py...

runLVs.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "runLVs.py", line 19, in <module>
    from LV3 import LV3_script
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2019-20/Coursework/StudentRepos/VictoriaBlanchard_VLB19/Week7/code/LV3.py", line 45
    RC0 = sc.array([R0, C0])RC = np.zeros([rows,2])
                             ^
SyntaxError: invalid syntax

======================================================================
Inspecting script file LV3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

### Plotting in Python
### Numerical integration using scipy
## The Lotka-Volterra model

import scipy as sc
import scipy.linalg
import scipy.integrate as integrate
import sys
import matplotlib.pylab as p
import numpy as np

# Define function 
def DiscreteTime(RC, t=0): 
    R = RC[0]
    C = RC[1]
    RNew = R * ((1 + r * (1 - R/K)- a * C))
    CNew = C * (1 - z + e * a * R)
    return sc.array([RNew, CNew])

# assign parameter values
if len(sys.argv) == 5:

    r = float(sys.argv[1]) #intrinsic growth rate of the resource population
    a = float(sys.argv[2]) #per captita search rate fore the resource (area x time^-1)
    z = float(sys.argv[3]) #mortality rate
    e = float(sys.argv[4]) #consumer efficiency
    K = float(sys.argv[5])
else: 
    r = 1. #intrinsic growth rate of the resource population
    a = 0.1 #per captita search rate fore the resource (area x time^-1)
    z = 1.5 #mortality rate
    e = 0.75 #consumer efficiency
    K = 35

#define time vector integrating from time point 0 to 30 using 1000 sub-divisions of time
timeseries = list(range(1,10))
timeseries = list(sc.linspace(1,15,100))
rows = len(timeseries)+1

#define time vector integrating from time point 0 to 30 using 1000 sub-divisions of time
timeseries = list(range(1,10))# Setting the initial conditions for the two populations (10 resources and 5 consumers per unit area), and convert the two into an array (because our function takes an array as input)R0 = 10
C0 = 5
RC0 = sc.array([R0, C0])RC = np.zeros([rows,2])
RC[:1] = RC0
RC
RC[0,0]
# Run discrete-time version of the LV modelfor t in timeseries:
    print(t)for t in timeseries:
    RC[t,0] = RC[t-1,0] * ((1 + r * (1 - RC[t-1,0]/K)- a * RC[t-1,1]))
    RC[t,1] = RC[t-1,1] * (1 - z + e*a* RC[t-1,1])
    
# Setting the initial conditions for the two populations (10 resources and 5 consumers 
# per unit area), and convert the two into an array (because our function takes an array as input)
R0 = 10
C0 = 5
RC0 = sc.array([R0, C0])
RC = np.zeros([rows,2])
RC[:1] = RC0

# Run discrete-time version of the LV modelfor t in timeseries:

for row in RC0:
    for t in timeseries:
        indexvalue = timeseries.index(t)
        RC0 = np.append(RC0,DiscreteTime(RC0[indexvalue],t))

# Add start time point 
timeseries.insert(0,0)

#### Plotting Figures

fig, (ax1, ax2) = p.subplots(1,2) # creating two graph plotting areas 

## Plot graph 1
ax1.plot(timeseries, RC[:,0], 'g-', label='Resource density') 
ax1.plot(timeseries, RC[:,1], 'b-', label='Consumer density')
ax1.grid()
ax1.legend(loc='best')
ax1.set(xlabel = 'Time', ylabel = 'Population density')

## Plot graph 2
ax2.plot(RC[:,0], RC[:,1], 'r-', label="Resource density")
ax2.grid()
ax2.set(xlabel = 'Resource Density', ylabel = 'Consumer Density')

## Add parameter values to graph
labelr = ' '.join(("r = ", str(r)))
labela = ' '.join(("a = ", str(a)))
labelz = ' '.join(("z = ", str(z)))
labele = ' '.join(("e = ", str(e)))
parameterlabels = '\n'.join((labelr,labela,labelz,labele))
boxproperties = dict(boxstyle='round', facecolor='white', alpha=0.5)
ax2.text(0.1, 0.95, parameterlabels, transform=ax2.transAxes, fontsize=9, verticalalignment='top', bbox=boxproperties)

## Put super title over the two graphs
fig.suptitle('Consumer-Resource population dynamics')

## Save figure to results folder
fig.savefig('../results/LV3_model.pdf')
**********************************************************************

Testing LV3.py...

LV3.py is a Python script file;

checking for docstrings...

Found one or more functions, but completely missing docstrings
2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
  File "LV3.py", line 45
    RC0 = sc.array([R0, C0])RC = np.zeros([rows,2])
                             ^
SyntaxError: invalid syntax

======================================================================
Inspecting script file profileme2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: profileme2.py
# Date: 25 November 2019

""" another script to demonstrate profiling in python"""

def my_squares(iters):
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme2.py...

profileme2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 96.0

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 3.63609s

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: timeitme.py
# Date: 25 November 2019

##############################################################################
""" loops vs. list comprehensions: which is faster? """
##############################################################################

iters = 1000000

import timeit

from profileme import my_squares as my_squares_loops

from profileme2 import my_squares as my_squares_lc

##############################################################################
# loops vs. the join method for strings: which is faster?
##############################################################################

mystring = "my string"

from profileme import my_join as my_join_join

from profileme2 import my_join as my_join**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00466s

======================================================================
Inspecting script file blackbirds.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Print Kingdom, Phylum, and Species from a CSV"""

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: blackbirds.py
# Date: 25 November 2019

### Imports
import re

# Read the file (using a different, more python 3 way, just for fun!)
with open('../data/blackbirds.txt', 'r') as f:
    text = f.read()

# replace \t's and \n's with a spaces:
text = text.replace('\t',' ')
text = text.replace('\n',' ')

# First encode into ascii bytes
text = text.encode('ascii', 'ignore') 
# Decode back to string
text = text.decode('ascii', 'ignore') 

# Find all Kingdoms, Phyla, and Species
Kingdom = re.findall(r'Kingdom\s+\w+', text) # Find all kingdoms
Phylum = re.findall(r'Phylum\s+\w+', text) # Find all Phyla
Species = re.findall(r'Species\s+\w+', text) # Find all Species


### Print all 
for i in range(len(Kingdom)): 
    print (Kingdom[i])
    print (Phylum[i])
    print (Species[i], '\n')
**********************************************************************

Testing blackbirds.py...

blackbirds.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 

**********************************************************************
Kingdom Animalia
Phylum Chordata
Species Euphagus 

Kingdom Animalia
Phylum Chordata
Species Euphagus 

Kingdom Animalia
Phylum Chordata
Species Turdus 

Kingdom Animalia
Phylum Chordata
Species Agelaius 


**********************************************************************

Code ran without errors

Time consumed = 0.03305s

======================================================================
Inspecting script file Nets.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: Nets.py
# Date: 25 October 2019

""" This program creates a network model of interactions between 
university-affiliated institutions """

# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)

# OUTPUT
# Network model figure in results folder


### Imports
import networkx as nx
import scipy as sc
import matplotlib.pylab as p
import csv
import pandas
import numpy as np


### Import csv files 
links = pandas.read_csv('../data/QMEE_Net_Mat_edges.csv', header =0)
nodes = pandas.read_csv('../data/QMEE_Net_Mat_nodes.csv', header =0)

### Generate an adjacency list representing a food web

#create indicies for each row in the links data frame
links.index = ["ICL", "UoR", "CEH", "ZSL", "CEFAS", "NonAc"]
#stack the data frame into three columns
links = links.stack().reset_index()
links = links[(links != 0).all(1)]
AdjL = sc.array(links)
AdjL = np.delete(AdjL,2,1)

AdjL

### Save university ID (node) data
#Sps = nodes.iloc[:,0]# get University ids
Sps = sc.unique(AdjL)
Sps
### Use a circular configuration

pos = nx.circular_layout(Sps) # calculate the coordinates using networkx

# Generate a networkx graph object
G = nx.Graph()

# Add nodes and links to it
G.add_nodes_from(Sps)
G.add_edges_from(AdjL)

colours = ['lime', 'lime', 'blue', 'red', 'blue', 'lime']
# Generate node sizes that are proportional to (log) body sizes
#NodSizs= 1000 * (Sizs-min(Sizs))/(max(Sizs)-min(Sizs)) 
#Need to make arrow size

# Render the graph 
f3 = p.figure()
nx.draw_networkx(G, pos, node_size = 4500, node_color = colours, arrowsize=20, arrowstyle='fancy')
nx.coloring.greedy_color(G, strategy = 'independent_set')

# Save file
f3.savefig('../results/Nets.svg')



**********************************************************************

Testing Nets.py...

Nets.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:522: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(edge_color) \
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:543: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if cb.is_string_like(edge_color) or len(edge_color) == 1:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:724: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(label):
Traceback (most recent call last):
  File "Nets.py", line 66, in <module>
    nx.coloring.greedy_color(G, strategy = 'independent_set')
  File "/usr/lib/python3/dist-packages/networkx/algorithms/coloring/greedy_coloring.py", line 272, in greedy_color
    nodes = strategy(G, colors)
TypeError: 'str' object is not callable

======================================================================
Inspecting script file TestR.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript

print("Hello, this is R!")**********************************************************************

Testing TestR.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Hello, this is R!"

**********************************************************************

Code ran without errors

Time consumed = 0.09979s

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: profileme.py
# Date: 25 November 2019

""" Create a script to use in profiling. 
Tutorial on profiling in python """

def my_squares(iters):
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 94.5

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 7.30035s

======================================================================
Inspecting script file fmr.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript

# Plots log(field metabolic rate) against log(body mass) for the Nagy et al 
# 1999 dataset to a file fmr.pdf.

cat("Reading CSV\n") #print "Reading CSV" and a new line

nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE) # reading in the data without converting strings to factors

cat("Creating graph\n") # print "Creating graph" and a new line
pdf('../results/fmr_plot.pdf', 11, 8.5) # opens a pdf to plot graph into with a width of 11 inches and a height of 8 inches
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3') # assigning colours to variables
# plotting log 10 scaled data from nagy with point size of 19
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class], 
     xlab=~log[10](M), ylab=~log[10](FMR)) # labelling x and y axis

for(class in unique(nagy$Class)){ #for each different class in the nagy class column 
    model <- lm(log10(FMR.kJ.day.1) ~ log10(M.g), data=nagy[nagy$Class==class,]) #fit linear regression to nagy data
    abline(model, col=col[class]) #plot line from the model with a colour that corresponds to the class (assigned in line 10)
}
dev.off() # closes the pdf

cat("Finished in R!\n Graph saved in results folder \n") 
**********************************************************************

Testing fmr.R...

Output (only first 500 characters): 

**********************************************************************
Reading CSV
Creating graph
null device 
          1 
Finished in R!
 Graph saved in results folder 

**********************************************************************

Code ran without errors

Time consumed = 0.18255s

======================================================================
Inspecting script file MyFirstJupyterNb.ipynb...

File contents are:
**********************************************************************
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this is python!\n"
     ]
    }
   ],
   "source": [
    "a = \"this is python!\"; print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0.22.0'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "pd.__version__"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Building and analysing mathematical models in Jupyter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as p"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sympy import *\n",
    "import scipy as sc\n",
    "init_printing()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "sympy.core.symbol.Symbol"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x = var('x')\n",
    "type(x) #check it's class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "a, b, c = var(\"a, b, c\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = var('x', real=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x.is_imaginary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = Symbol('x', positive=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAC0AAAAPBAMAAACCUFuUAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAMqvdmc0Qu+8iZlR2iUR1i74cAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA+UlEQVQYGWMQsv/kovo/gQEIhGJBJAzIFzAwSAiAeGxNMDEQPV+BgYFrA1ikCExCCZA42wEGEEAXn8ZwAav4SgaGPWcPgNQznl4TwDBlrSZQGdCcSgZuSwYnkHg6A4MBnxnDiwSgeIvGTwbuRob3CUBxoMABjgsMHEDNQPVAbYxn/ScAxZm/n2SQ91q1aAFYfCUDW/gEeZA429X/Dvshjga5k4HdgEF+GlB8GgPXP3mgIUAAFue/wLB/nkARwxsGBi3mAAa2AwwM8goMDAwcBQz3pRLA9lYy/mZgSWCYYv/dk4GBU+VsTpTQf823a9Y+YEjyuQZUih0AAHGBRtIqn6whAAAAAElFTkSuQmCC\n",
      "text/latex": [
       "$$\\mathrm{False}$$"
      ],
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x > 0\n",
    "x < 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Symbolic equations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAEgAAAAbBAMAAAAt2dQtAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJqzJu81j5AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABYElEQVQoFY2SLUzDUBDH/+uWtIUyCgaBqSFBNgGSGRI+EiwgKgiBLNOISUAVQxB81AEOD8lwGAIYpjAEi8AiCJBKRLl790qz0LQ7cZ+/3LuXO6BMukt+GQLHHVophUy3/l0OXVd+SiHAjvuAzLAPqEtMxSOVL7ZLeaNJajofUNln0re4A1YLoBmgvna+KN0y7ixzyXNCDCTJF0x+N5NeqHohlbEMYK8XwrpU98k0jsYPQwk1ZHWSJGkC/H2SBaD6YGybeosaenrfmxyh6oRisEPj+U48qEcTqB457jHXTwW6pE6ozangMQh2g2CD/Rpe2HyyAggChkPWLOngH2hzqCF6jvw31iwp1ILa/Y1kaXDbP4HlS6ihagx1RXpw+uR9tIxRYdJOVhtXnNmSNDWcPWi0PIlSqBbhlTObki5ei5pen4tuQ2Yqc8mjBYvMa5tn6FREio7ur0HF0/R/Y+hd/QImF0Lvgv7FCwAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\left(x + \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "       2\n",
       "(x + π) "
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "MyFun = (pi + x)**2; MyFun"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\\\\left(x + \\\\pi\\\\right)^{2}'"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "latex(MyFun)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\\left(x + \\pi\\right)^{2}\n"
     ]
    }
   ],
   "source": [
    "print(latex(MyFun))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Numerical evaluation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/latex": [
       "$$3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068$$"
      ],
      "text/plain": [
       "3.1415926535897932384626433832795028841971693993751058209749445923078164062862\n",
       "08998628034825342117068"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pi.evalf(n=100) # pi to a 100 places after decimal!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/latex": [
       "$$3.1415926535897932384626433832795028841971693993751$$"
      ],
      "text/plain": [
       "3.1415926535897932384626433832795028841971693993751"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "N(pi, 50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAHUAAAAbBAMAAACw1N2lAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJqzJu81j5AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACIUlEQVQ4EZ2TP0wUURDGv7u9g1t2wcNCC0lcSLT1FSYQEwMaKpo7iguFzQWRgkYsNBgLtiKEYDgTGxso+JOIBduZ0LAkhlCAuUYLqmvsTM5ILlbknJm3b89LToM7ye18b2Z+u3Pz3gOSmTvzOBlI1CG+JGafoZ5PCr/CzSApC2yo5OxCctQtE5vy6PE/9kaKb/PzbicudfKp8ke8rxwt3OXP6OUBO6FTAyajcJu7BvunBOxNdt1VgJX1CE9gFSny7d1bhXSZk8ZsX6u1Cn6xun96zm6lqlWmjHHgmCJ7zSa9kjuIzbD7ARoSTDObukXfZXUgxfdM+XUjxBuWWtQ9C+tmI3ZCirJBxCyRH3l9Y9WXdYsdDiUg7KBhG9+XiJPt4exDmkCYXuguSmnMDrxQMWv5EWs1PLyk7nUtWLvKPXfy7SxyH2LWhWFpPnMK9rykACqxkBnjlVsqTW2XSlWd2VXsued1w/Ls7wTo+6ErmAWu+NHK9NwPFCocI9YKY/Y5sV6LpZ6Beo2fZIZtqhZrf519uuNLB2fyXWdeF/OsbLWGnHQYs1vAokRkzuip6u7rCnOkihF7RDteKeCqXprvDvH+jlJNTs5Vz5hWvaH1HugKoe0jHbzlkWlPrwzrzM4EfIq7zhrTNMTChafV0WkNyNJPrPOZjJKd3bAJt98FS/6kyf3F813Q9sCIy3q5g7q4493/13sy+Tib8mJ5OTFoyn4DlUWJXgDaBIkAAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$\\left(x + 3.1416\\right)^{2}$$"
      ],
      "text/plain": [
       "            2\n",
       "(x + 3.1416) "
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "N(MyFun,5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAFYAAAAbBAMAAAAUvmV2AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJqzJu81j5AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABkUlEQVQ4EY2SPUjDUBDH/2kksSVtg4OOZhHExYA6+1EQ3KoQQfyg4KrSVUGoi4KLblYnd4d2cxGpg92U6uQg6CQ4qYguCvFe7uWriOaGd/f+9+Ny73JAQmtO2glJGGa2mJTVzdxbYraufCVlgfR7clavJGebhCoWHX9a2qR0qkTHcMjN2E/74S2Mbig8wzkwTcERz7nmfodAJBoBcnOHBVFbvX9gduFOfE1YlZ08jQoyrvsKXaQHmW0FRJxVjznRI9w/LOaZ3Y6wt/1rLAY97Lqu+wmIeZFNiEPWLaC3Lq5Bv8Z1tWuLmuxjdV04yQIdZVZlv8+46Hwk5YDVE+ECVhPLdOk4G46z6OXHsjb5Fy9GhKUNNeQy+XPItXSBSTbSQ6YITS6Tz2pWXtQ95bqRt2mAXmTVZ0ftfJ0U+TZvHHs21A8oJQyYcXYHmQYpK6yK8qu1WQubQPfVMovBfKeQbZC0xLL3jyUROr8HVtQye28vQ0hGQzGFdodtPCb/eqGdZIvsui+1+6CcYrWn2u8pOZwfO6dQIT3zDYsAAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$\\left(1.5 + \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "         2\n",
       "(1.5 + π) "
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "MyFun.subs(x, 1.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAFYAAAAbBAMAAAAUvmV2AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJqzJu81j5AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABkUlEQVQ4EY2SPUjDUBDH/2kksSVtg4OOZhHExYA6+1EQ3KoQQfyg4KrSVUGoi4KLblYnd4d2cxGpg92U6uQg6CQ4qYguCvFe7uWriOaGd/f+9+Ny73JAQmtO2glJGGa2mJTVzdxbYraufCVlgfR7clavJGebhCoWHX9a2qR0qkTHcMjN2E/74S2Mbig8wzkwTcERz7nmfodAJBoBcnOHBVFbvX9gduFOfE1YlZ08jQoyrvsKXaQHmW0FRJxVjznRI9w/LOaZ3Y6wt/1rLAY97Lqu+wmIeZFNiEPWLaC3Lq5Bv8Z1tWuLmuxjdV04yQIdZVZlv8+46Hwk5YDVE+ECVhPLdOk4G46z6OXHsjb5Fy9GhKUNNeQy+XPItXSBSTbSQ6YITS6Tz2pWXtQ95bqRt2mAXmTVZ0ftfJ0U+TZvHHs21A8oJQyYcXYHmQYpK6yK8qu1WQubQPfVMovBfKeQbZC0xLL3jyUROr8HVtQye28vQ0hGQzGFdodtPCb/eqGdZIvsui+1+6CcYrWn2u8pOZwfO6dQIT3zDYsAAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$\\left(1.5 + \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "         2\n",
       "(1.5 + π) "
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "MyFun.subs(x, 1.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAFIAAAAbBAMAAAAdVcUMAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJMqtHo0JKAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABn0lEQVQ4EY2SP0jDQBTGvzS1SWsi59RNugiOHXS19Q/OOgQRkRaF4tChq4vGxUUKnRQnRRFBBd0EUejUqYOri1ZEdBBa6eCgEN/lcucfWsmD3L37vl9e7nIPCBW1qXQoDhbrmw5HGsx+C0meax/hSCDeDksabliyRqCWouGfiDMyI3kahjtRemHyRuoPlFzhGpiRys95FJY67Ahgz+1MiLoKirsiXQKOpWi5SHheCwbfhgpJHgFNaeh7wk4qiieSzKXRVBudF8gGTVpx+UCsJEmrtbR55nleHuB/iGKcnkvW0/IXqibQ+4n67fpQP+mDwlsB9H3Esn9Jo2FXLFbm8rbwToBYG/5lWY4ze+g4Dd8o0BjFI8/vfQFEJrLIBNtX+zTzZN+hxKGApK9nqtjlCoUit6AxLMLvoAvh0YkyFTz5t/tN2lWYTG/Dv6jgRPQLom5k1RLvyZrJeu0ZZgmnXC4Kj0rrL+WBzd9kzvPeEa3glcsLwut8m8ITo+4fK+g8ZehplaqEOkTEmJK6JNR1Ijp2sjT5rEppKb7sHhEmvC+K7lb+N5WoIgAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\left(a + 2 \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "         2\n",
       "(a + 2⋅π) "
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "MyFun.subs(x, a+pi)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAFIAAAAbBAMAAAAdVcUMAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJMqtHo0JKAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABn0lEQVQ4EY2SP0jDQBTGvzS1SWsi59RNugiOHXS19Q/OOgQRkRaF4tChq4vGxUUKnRQnRRFBBd0EUejUqYOri1ZEdBBa6eCgEN/lcucfWsmD3L37vl9e7nIPCBW1qXQoDhbrmw5HGsx+C0meax/hSCDeDksabliyRqCWouGfiDMyI3kahjtRemHyRuoPlFzhGpiRys95FJY67Ahgz+1MiLoKirsiXQKOpWi5SHheCwbfhgpJHgFNaeh7wk4qiieSzKXRVBudF8gGTVpx+UCsJEmrtbR55nleHuB/iGKcnkvW0/IXqibQ+4n67fpQP+mDwlsB9H3Esn9Jo2FXLFbm8rbwToBYG/5lWY4ze+g4Dd8o0BjFI8/vfQFEJrLIBNtX+zTzZN+hxKGApK9nqtjlCoUit6AxLMLvoAvh0YkyFTz5t/tN2lWYTG/Dv6jgRPQLom5k1RLvyZrJeu0ZZgmnXC4Kj0rrL+WBzd9kzvPeEa3glcsLwut8m8ITo+4fK+g8ZehplaqEOkTEmJK6JNR1Ijp2sjT5rEppKb7sHhEmvC+K7lb+N5WoIgAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\left(a + 2 \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "         2\n",
       "(a + 2⋅π) "
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "MyFun_new = MyFun.subs(x, a+pi); MyFun_new"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_vec = sc.arange(0, 10, 0.1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "MyFun_vec = sc.array([N(MyFun.subs(x, xx)) for xx in x_vec]) #Note: using a list comprehension!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "MyFun_new_vec = sc.array([N((MyFun_new).subs(a, xx)) for xx in x_vec])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x7f18f842f048>]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f18f84f8630>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax = p.subplots()\n",
    "ax.plot(x_vec, MyFun_vec)\n",
    "ax.plot(x_vec, MyFun_new_vec)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "MyFun_lamb = lambdify([x], MyFun, 'numpy')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "MyFun_vec = MyFun_lamb(x_vec)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "22.7 ms ± 652 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit \n",
    "\n",
    "MyFun_vec = sc.array([N(((x+pi)**2).subs(x,xx)) for xx in x_vec])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.9 µs ± 201 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "MyFun_vec = MyFun_lamb(x_vec)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fundamental mathematical operations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Expand and factor**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIAAAAAWBAMAAAD6L4mmAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEHarIkSJZt3NuzJUme9mZ+xlAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABl0lEQVQ4EZ2Tv0rDUBSHf4ltGpqioX2BoOLiYF3ErRkUHZ1cHOzUrSA+QfEF7GhAqK6CKLgK9gEU6tSpq+iiFlTcYnLP/XNMi9JmuPfc8/2+Q7gkAD3NS19Wk2zGcsKZ9iQmZZnlht7H5AOY5e7kPqcYwK3ScPIBALPcYJoBzGpmfGtwcZ1pjTkaq9DL4Aqc/2+FWbvYowmlgPZH4DUzMzkqKom24J3en1NTRZ6BWihzZlOUOsbCbBy/U1NFOj5qo5egKGXJKi9sLgXUSFcWOfbttziOezARRSVIBateOHLbaUWPigD5LzRuFw83eERRAsJwfGeYD6WdbCoCuFWv64TLAItIKoGwLBTPtO5E0clLFFVFY5CsRawmLykjnAogvblAFmLTb2D3kvMNWmlXRzSVIIW4+3XZOvKAXIg+xC+iI5pKkOglfwW2LyaJRUW8OuzQGiL5HFlEUQJC2O9eYcv4+hK3G8112C08ASyiBhAQWmW+3D8YM6ATx98odrEGsIgaQIBpplQR0+HV31QkLXYfXKV6lP4ARYJq5GFzLW8AAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$x^{2} + 2 \\pi x + \\pi^{2}$$"
      ],
      "text/plain": [
       " 2            2\n",
       "x  + 2⋅π⋅x + π "
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "expand(MyFun)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x**2 + 2*pi*x + pi**2\n"
     ]
    }
   ],
   "source": [
    "print(expand(MyFun))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAEgAAAAbBAMAAAAt2dQtAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAImYQu82Z3XZU70SJqzJu81j5AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABYElEQVQoFY2SLUzDUBDH/+uWtIUyCgaBqSFBNgGSGRI+EiwgKgiBLNOISUAVQxB81AEOD8lwGAIYpjAEi8AiCJBKRLl790qz0LQ7cZ+/3LuXO6BMukt+GQLHHVophUy3/l0OXVd+SiHAjvuAzLAPqEtMxSOVL7ZLeaNJajofUNln0re4A1YLoBmgvna+KN0y7ixzyXNCDCTJF0x+N5NeqHohlbEMYK8XwrpU98k0jsYPQwk1ZHWSJGkC/H2SBaD6YGybeosaenrfmxyh6oRisEPj+U48qEcTqB457jHXTwW6pE6ozangMQh2g2CD/Rpe2HyyAggChkPWLOngH2hzqCF6jvw31iwp1ILa/Y1kaXDbP4HlS6ihagx1RXpw+uR9tIxRYdJOVhtXnNmSNDWcPWi0PIlSqBbhlTObki5ei5pen4tuQ2Yqc8mjBYvMa5tn6FREio7ur0HF0/R/Y+hd/QImF0Lvgv7FCwAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\left(x + \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "       2\n",
       "(x + π) "
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "factor(x**2 + 2*pi*x + pi**2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Apart and together"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIIAAAAvBAMAAADdrw/+AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAVO8Qq4lmdpnNIrvdRDJuPMnUAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACDElEQVRIDe2UPUgjURDH/3trPk1ErOQawQNBT3GRdB5EhEMEISk8TJlaBMM1d41ewLtTsDDlRYRsYXGFhdUJ2igIloq1RWorRSwENc7M2427y9MUy1Vmivcx83v/N2/2vQX+u/VY4bYwP+dCKgCLbQX5CO06qLsYvg4/wt6on6N/iuEeRnv1G6tAI6y9sXq9dtxk8aXoexVoCYy/JIAOW0JawFw7qLvAplbB+ACYFQlpgQwiDw4QLXsVjJKaZWZvaDDHEz2wAvQ7QMpmzDVXAVFWGGO3HhgGcrYCdtzF0vsVEmfk1AM1C7k6BPhOUPLXKh2bza8QKZOLAfwtfFW/3CYAnFoQ4B/Fz+3EFXNBhWiFXAykh1DjsAdA+pZqxMAR1XwA8V2JB3IwDhWAsSLWAwBSE6THwAgQv0GqRMNItbo1WK1ShNS5kl1X1BCADQsn1HkBrHmAd7vI1mlO1jymX+EjzMcAECuTQ7agU2Tz6FPxgEL6kNx8zFsYnA5Zc4teJG0IQIXKdmPasP2A5OBW0rxGR0W9ElehK4+YDQEKQGcpehwRgectYlyHeJ4aArCHhQkeP+ew86Uw4wAXlOTU8vaSxJsK8cm730CiTl4CkPl2OXUmhJtDrdG4dwD9pRUan7hrCfgfjmmptarVvCwNgH3vGt/Yed0tAe0PRJQ6belaAsmicJpmXvleB54AbevBYvg/zT0AAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$\\frac{1}{\\left(a + 1\\right) \\left(a + 2\\right)}$$"
      ],
      "text/plain": [
       "       1       \n",
       "───────────────\n",
       "(a + 1)⋅(a + 2)"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "f1 = 1/((a+1)*(a+2)); f1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAI4AAAAsBAMAAABBB53eAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEM0yVO+riWZ2mSJEu92sN7DKAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABwklEQVRIDWNgoCFwFSDGcJZA/KoY0/OJMUes7CN+cxgY+okxh4Fj1By8ATkaPniDh4j0M5+odMhJKB0ui9dqwO8UkCxX6qcVhFUNdhUsE6jjwlFz8IcjwfARUgIBZQaG/9jBB6D57EpKekFKSglAJj92Vf/xuwIhS9A9CKV4WaPmYAkeqbWXYaKUhA9jAkP9AahBjHiKNpwVvSdEM5cAA2sAzEFYaKgy3BU9VAHrAwa231j0w4SgynAX1FAFTB8Z2D7DNGGhcZjDvXwltEUDU8DAwIdZlu+qmgoNK5gytIr16AYmUGYCApgCBobzBRARBMkTzaAP5cGUoZrDGMHAdQGiAqaAgeEZwgAoS7SBYS1ec7g+MvBNAKooUlJ6qqSkBlbLtQCqBUGtF2B4CeIhKUN1D+sFBnkDiHq4e2Yh9MNYsQyMsLCHKUM1R76AwR+qGKaAZQHDbph+KM34nYHlA5oyNHMcGJJYNoCVwMwxZ2CYjW7OFwY2BW+IIEwZqjm8EziesaMo4H5evuwBmjkMNxn6EgpQlDGgVvSMmZO3zUFRwAQsQzHMEZtpnXkARRnuih7mYIhynCRBZYI4taJIICsDAAPNmOFYzOHFAAAAAElFTkSuQmCC\n",
      "text/latex": [
       "$$- \\frac{1}{a + 2} + \\frac{1}{a + 1}$$"
      ],
      "text/plain": [
       "    1       1  \n",
       "- ───── + ─────\n",
       "  a + 2   a + 1"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "apart(f1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAHwAAAAsBAMAAABVvsF6AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAVO8Qq4lmdpnNIkS73TJc4EnkAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB4ElEQVRIDe2WvUtCURjGHz35kWZGS9EiFAR9kZS7EoQ0hA4JNgT+A5G4NAQl9OUQ5NDQHcI7FLQE0dRoU0MNEUVjzk2KOESUnTznXO+XJtQQ5Bnuve/zvL9z3vvec70CvzZ6/a1MZRkyzSKzkVbwwELZFAdWWsFhb+PG/v3n1m20tG0cDbbN1uRhwthPveKced3Ra380tiR/VFgbb9K+qvkoUsQmSUcjkhSil17zrGqTib+sdue/aZDOPoldCaVJ60jmtiDS1GdXGr4EF0jjX5AAbG9qDH0scpTgvdMYmkAUtAkMagyOu8fgzWoMTSDwCSAiqx2OU0kpXm3za4Hn/IgUANf2Lv9iKzh5NGKn8RTrg8BpyjNVLuTOIssWuGuJ3pduuEeRY1Idd1cAMgxnnhkCB1LnOhpTCezpcU8IcJbhSVJjUZLuJemApVgNf0D2/XiinuolBDJUsOYRLDCIr+6S0VViSv04DvLBIqV4R5oKwSh8PIvj3rIRJxVYeIcUvB90oWAP5ixybQKO03o8+g8RKaEjO1DLEnh3FA5aZ9L+YGPLc9yeMHnu11gORTX4WSw+TzsfXj9e0+C4zNwwQXUMrL6E2eMQq+eq1XdVAsSe12jGQOAGZ9qgmAnEr1I/AeTDmkunD146AAAAAElFTkSuQmCC\n",
      "text/latex": [
       "$$\\frac{1}{a + 3} + \\frac{1}{a + 2}$$"
      ],
      "text/plain": [
       "  1       1  \n",
       "───── + ─────\n",
       "a + 3   a + 2"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "f2 = 1/(a+2) + 1/(a+3); f2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIIAAAAvBAMAAADdrw/+AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEJm7MquJRO/dIs12VGbfGimAAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACv0lEQVRIDe2WT2gTQRTGv02af7tNWJRCe+raYE9KC3pRRHPy4Cl4kxa6VOypYI71pNKD/QMShHpRcSkotKdeNYeEIihFMHjsxXrUQ2lAWlR0fTOzk26S12bVnsSB7Ox+7/e+nZmd3Regsx3Ln+0UAetjz2lO79SMIm6WOmWkfd9lZEaK2UjfCenZmrqwbmyE1MNO02UkvoUA7ZAIaYefWg0kvoSQ33eg5EwD5vCpu8qm6bC9XlBKhONtFzOetaNI7RC3zb0IuQpZgnEfsdFWB7o6F9Uh5iDWQKZGfLJSebFYqRRV6oin+q7HdSA9isGCAvUsxsDvE8Yu62B10MWHIKQdFoERm8EZ6TKwMVjHWNaTQe3gAI8YmpHMh1Mny/FabimpgtphGbkFBmcky/f9sjH+6tnrVgdz+GrESbSb6jG069GvjT+8c/Q7/CePagVo+/xdO6qB/AM+5tZBk9hUga7Acc7AGDpTQMKTIRYwp67XNfBSYm2HPiT3YKxJlQWWkf0ZADknnKw/BieAOWBahHjgXR1fAyDjcQ7zwISHfhHigZkSvkMBK2ED6DFUbUwUYJUoyAMQs1AAFQemSJL41EbSoV4AWJ58oz5V+hbAgEsFyaHYRfp1FkkgtUtLIJZSAKkFVKmj1nR4/oAsJfAEfJHMFAkvUw4B6N9CXuSHHNB7LwCoZ4vkEOE9O3QgQBSrx9S1VtE5uwkwRRK9DmU0HWZhBH9K9CxWgUt1BdAgmSKJ9zA9pIJZGLvIiuFQ0w6+LRwkQAvFFMkeF71ecyWNH0isbbY4zMqHJVdyEmCK5MrU5DVaIJeyCMAFfCqK8/0xbMv9IIFb9Cw6i2TV92nTWgXKIQB9b6+Ml6jfd0gN5UmQAL9pJY0B0XUFWl+c1iI5LRy6AjgvMLYFb3dXgP2ASMe4J7uuwMEfsc9qZIcDvwDYJP++gGwiTQAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\frac{2 a + 5}{\\left(a + 2\\right) \\left(a + 3\\right)}$$"
      ],
      "text/plain": [
       "    2⋅a + 5    \n",
       "───────────────\n",
       "(a + 2)⋅(a + 3)"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "together(f2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Simplification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIIAAAAvBAMAAADdrw/+AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEJm7MquJRO/dIs12VGbfGimAAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACv0lEQVRIDe2WT2gTQRTGv02af7tNWJRCe+raYE9KC3pRRHPy4Cl4kxa6VOypYI71pNKD/QMShHpRcSkotKdeNYeEIihFMHjsxXrUQ2lAWlR0fTOzk26S12bVnsSB7Ox+7/e+nZmd3Regsx3Ln+0UAetjz2lO79SMIm6WOmWkfd9lZEaK2UjfCenZmrqwbmyE1MNO02UkvoUA7ZAIaYefWg0kvoSQ33eg5EwD5vCpu8qm6bC9XlBKhONtFzOetaNI7RC3zb0IuQpZgnEfsdFWB7o6F9Uh5iDWQKZGfLJSebFYqRRV6oin+q7HdSA9isGCAvUsxsDvE8Yu62B10MWHIKQdFoERm8EZ6TKwMVjHWNaTQe3gAI8YmpHMh1Mny/FabimpgtphGbkFBmcky/f9sjH+6tnrVgdz+GrESbSb6jG069GvjT+8c/Q7/CePagVo+/xdO6qB/AM+5tZBk9hUga7Acc7AGDpTQMKTIRYwp67XNfBSYm2HPiT3YKxJlQWWkf0ZADknnKw/BieAOWBahHjgXR1fAyDjcQ7zwISHfhHigZkSvkMBK2ED6DFUbUwUYJUoyAMQs1AAFQemSJL41EbSoV4AWJ58oz5V+hbAgEsFyaHYRfp1FkkgtUtLIJZSAKkFVKmj1nR4/oAsJfAEfJHMFAkvUw4B6N9CXuSHHNB7LwCoZ4vkEOE9O3QgQBSrx9S1VtE5uwkwRRK9DmU0HWZhBH9K9CxWgUt1BdAgmSKJ9zA9pIJZGLvIiuFQ0w6+LRwkQAvFFMkeF71ecyWNH0isbbY4zMqHJVdyEmCK5MrU5DVaIJeyCMAFfCqK8/0xbMv9IIFb9Cw6i2TV92nTWgXKIQB9b6+Ml6jfd0gN5UmQAL9pJY0B0XUFWl+c1iI5LRy6AjgvMLYFb3dXgP2ASMe4J7uuwMEfsc9qZIcDvwDYJP++gGwiTQAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\frac{2 a + 5}{\\left(a + 2\\right) \\left(a + 3\\right)}$$"
      ],
      "text/plain": [
       "    2⋅a + 5    \n",
       "───────────────\n",
       "(a + 2)⋅(a + 3)"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "simplify(f2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Differentiation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAEQAAAAQBAMAAABdIsRgAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEJm7MquJRO/dIs12VGbfGimAAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABJElEQVQoFW2QMUsDQRCFXySXGLmYTRGxEDRnKyjYKhwpBeFaQcwSxcI0/ocgqL1gIXixswk2qa64NpFUARtJkdZORKIWss6YzOEGp9h57+3H7jBIeZs+/q2KpCVkPkTb/UpsGTgXzX0gxj0TdQFUQzHUE6TVljRWqPpi/iI6QSi9VbirddSYk1fmQ0I6xpg3yrMjZC8Rj4nkoyW0kTkatB5DusgFWBxidQrRhOzixPU594B1hRuW9Si6jiIeIu8TAmw4/L+7AjSQeifJNZllAYykgxxnfcw1R8i/sqaaIE+e97mGmWGBXklruM1vOA/PFkKGVresCqfA/XFtD1t4CfQ00gC6mKU4NuYLpd7OPuFcshccmgNsw9G/qXUkiJVapmg5Nj/m8kjK2dlUkgAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$2 a + 4 \\pi$$"
      ],
      "text/plain": [
       "2⋅a + 4⋅π"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "diff(MyFun_new, a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAOBAMAAAAPuiubAAAALVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAOrOgAAAADnRSTlMAEJm7MquJRO/dIs12VHWsM+wAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVAgdY2BUMnZgYBBlYHvOwKDIwNDBwNDJwBC3gGGfAEMcUIKBYZ4AkGB/BmJyBoBIJRDBowAiLzFwLWBgSWDgWcCwMi0pkoFh37t3LxkABZYPUKJR+4UAAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$2$$"
      ],
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "diff(MyFun_new, a, a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAGsAAAAbBAMAAACJs2z+AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAVO8Qq4lmdpnNuzJE3SJtjddMAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACEklEQVQ4EZ1UO2sUYRQ9O4/szL4Sq4iFkQh24qApbGQXG0khmcIQRYgprSRYCWpYMGpIlcJmq6ytNmthYeXgH3CQiI3EKSSdGlgEg4/x3Pnm2+xsRiRzi/ude849871mBjh02OsPDu2hYRGzRWzbeB0V8H3Et6CADZjyCtk+FHLZ7VHbzigxUh+X+qYmzbVnPcFmVzPD4/n157q0IqDm19hcOgnMwP4likv2QJgt3AhS1twAXh055mHmSh/gtU+LMJg+6ZpUvY4H44SCwAJwJo5ZjdF2GpiLiLe1moypzQhh/dHCWQ3EtulhjutthJoctrl9WD+14AYpEhvjkweU2wSNh4+5W4l0NqJ6H7fjOP4BDA5f2WrfqVaWmN5E7i4Hxr7trW9fn9xZibiljURSe+PzWizrE7yDU3C6Stq3beEFFss90qVQacmRAGtSGQHg9FFfJr7W6bzrdJ4IDafN1LU85uouk0SyyGRXic3ootlTymC2O6yrrbqwWdtRNCK1yKaPKdEZ2lZq4yucpXGZrRYmkpqt6qMcqSNpTmC2RMzQtpfACpreeEBucCRlXsCX+auXycnpVpbHtmxiRmprvJ9fDXEfhk/OkSTjxb1H2Izj38SyAvPS3c/3EkXbXN5YiKewxOH2lJbJuS9XpuNCpkqL7Kt8LqdlIYdDJcpjhzj5cA5G/mc61PeP5/7vp3ArfcRf5Sp5cMUaIdcAAAAASUVORK5CYII=\n",
      "text/latex": [
       "$$12 \\left(a + 2 \\pi\\right)^{2}$$"
      ],
      "text/plain": [
       "            2\n",
       "12⋅(a + 2⋅π) "
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "diff(MyFun_new**2, a, 2) # same as above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAALEAAAAWBAMAAAB9HmCgAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAVO8Qq4lmdpnNuzJE3SJtjddMAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACzklEQVQ4EZ2UT0gUURzHv7Mzs2POrq4QKQUFZRBSNpQhHcKpyOwQbpCxGdgeCutQiBEeIluIbBFBQy970vBQdCgFD3XJvXSIiCQCL5EDgnSp/JOR/Xv9xp335rWzRtu7vN/7/r7fz5t9M/uAvJG4b+Up/7HUe28GUrqjDQTEooU2HAtkoo75KyAWLbzDpJMfimbLfuRrxa/f4lM2mFKWglrxypYCbyvaUTwnmJj2JDX9YIx3E7zw58dA/dU+fx2szBTUrkRWNPQUlco2oA46P92wq+WNN0AKWixPlZdRGyXAQSFdoKruJJ0rfX1bPfUZXnhVJfcZ1VCSUAf42p+FpdPGBmA/70TiETqDMJF3Ac3OqmzeqRj1+iI2NwR9BOqUp0sTt5RdtNEKHOCtJxUbrRx52EIzbUIjxNi81+cxxIcQ+WbpSU+XJm7R19l4NYpTvLWbMSrdZ6YxY+F9opN2EoPHws4Q/aQvJ4BOxthXSD5uuUxkjZ2PwSAmS3mIHDmyjEgthgWWCh6rB5F1Ngj9TOVctyP7PIvaQWScXbHQMt7d/pFDcmR6uXuS6OWiO3Ny3CVXvVzMjqPNoDOTfJ5FB5GVvpmdZkx3rglGjpwG+i1MC/V0JvM6kyEklDEih23coK9zRKPj4j7fsskln4OxaKEUhwVjlWykgBqo34VKhfdA+0DkkAVzAaYdJV3y5Sxq3CXTxpMxTGBKMFbJVSibXYYyL1SfvD6dXrzdQOtGlCTLLaiSL0dWmtL9O65QVkuiB/6145LNOIzZBWgDmyW098ykVCPkAA/RYJVnoUo+YQnZqAVKHXUJ/M8MGET+0JI4jnu4ZMcLkmsQGUS4A9cRIoPk88kjeG6hHcYUtnNEyaGVHgwz9hN1XU+PZrlMs4i1skZM3KIb6S40Iks+btEffU6aTXQjlcZwREKsUfLYGm1X/gdLofTeQuKf2t8svwHtILoj8Abu/gAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$12 a^{2} + 48 \\pi a + 48 \\pi^{2}$$"
      ],
      "text/plain": [
       "    2                2\n",
       "12⋅a  + 48⋅π⋅a + 48⋅π "
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "expand(diff(MyFun_new**2, a, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "x, y, z = var(\"x, y, z\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAKAAAAAUBAMAAAD4uit9AAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAMnZUZs0Qu91E7yKJmaurDqYVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACzklEQVQ4EX1VUUgUURQ94+6+2XVW24KoLx028KPa2q8KglqkIEhh+1hIghiCMEJqCSNIiIWKPvwRv8QCNTKQCBaSCiFYhIIoaQskAqlNqh8JtCKxNDvzdt7uPFu7MPvuOe/cM3PnzswCa2PcT+z3g5q5lfLRgXwZWHeqpMhWc6DRU/g5Pe/U4FwZGctVNqRZiHR1p3Z2QqNPa0iCdp2a9GDA1nmFgkWVyTVqa9AFvTpz1oPrGYa1hiCGpd7aWHGxcpVUJqG+Ml7P8LEuRweMba3pR3+w+f6mXTY369iCiM/1T+LUG1h3EfVaUoZiZiqJrvhzWUd9gvKEjQkHA2NGCpgCp5TDSeCGbf2mwCTZhSP2dRQGUTePYJokQxlOJI17Ri9MW9YB3UA0MozdEN2Jt9QdxqADG1eAy8APEuEk8AyvnJtWchpmFoEcSYYyzCAwEi7AWJB1wFXgQUMalyBgZanbh/DiDriGF4FvJOr7AIf7FNzGBhvGPMloJnN8NJMpkV0hbOZJl2UdMEZ5vS1LtzjuHsTT1aJrSA9lWM4iP9EcKxtS6F2h4WoO8qSLsk4aYsgxFoBIiVs0fIjgks/QbZkN8YeNbKcsx5ThGVaucEXWyZYxjbph4IDUDaAf+OQzdIeyh8NogVly6bVDydC7vghjSdbJoVBGbaCIRnhD6XH79VrmYxL5bs7zlW8oRTilhgJVDDWUiRReGCMIFTiUHvJTPN5jKIWtba0dzGdwq7Wtr2n1S9Pqx72/SrJFMduSOMT7P5vgcxSKUcVQhuLrzjyevHwn68gP8DgX/5BHMTjKW4tjPPTwvXq8izjj7SpDXczHLO8y04oWOZVV1naVfcZ5nnLSg8JRvL7y49CYFkuKjNoqq6ymPCXhNVxg37zI/0cPwinTVpoany+R9Tb7EzG+icpeVfyzdiISf11h3TmtjXE/cdQPaubaX0Awj78usLOuNbejmwAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$\\sin{\\left (x y \\right )} + \\cos{\\left (y z \\right )}$$"
      ],
      "text/plain": [
       "sin(x⋅y) + cos(y⋅z)"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "f = sin(x*y) +cos(y*z)\n",
    "f"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAPgAAAAUBAMAAABSee3BAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAEM0ydqsiRIlm3btUme8mhfXmAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADlElEQVRIDY1WS2gTURQ9k2nzTxxKC6KoIaKCq+IH3HWEKF0YjR8EF8K4UfyVLoqICxtF1I1YREQFIYgWxS6KPxBB48aFLgxVUXFhtaK4ECz+KlXjuTMvn3mjxQM3ufe88+59nzuZAAFsDzB+IjzQHN9vDqbwfVmTDiAWgDEcoPzETF/Y6vhCYNbLa4oJf2gMaVk3ckRMR8jRGS2e74uNjC+EUcDxXo8yJxpDWtY2jojpOKcTWhyr+IlDKkzarpOykB5VVNOXljVqA2I6BnVCi+OOn5itQlU8XULrN79CIi2rMQqIaQiXNEIPd2hESB2yKh4aR+tnTxJeXJcGsi7gkJgHI7exT06whafq+e1PEH7N4PmxMqbnjsBcdTJDQZ7WvmJbt23kbfRYiKprUMU5Gh+HK975FYs+LllhkwpkPUZSzMN0nLXP000MAJ5f3I+WT0BP2XxnDiJhs8tLFNzieoqxC/FMNDKKNUAsQ5JoFO8vAq54HnDFDsslBLKeICnm4QCOW3voxsuA64fLI0gMA1kkx+JFmJ/3W7ApGGKrWNHxiLMrlcFtFi2RJBrFLzJyxTeAO8APhoGsD0g+QFtWMBeWJCLSvfB8A28xzYbxi2RXGZiIT64UwXvu3F2VlbbxhQfM00E0m134JpstiCBV4YcrZvGrEE0gK7pIitUgIk/mTYiMo6sTptCPuKJJ42BV0rI4ZFVAv2WytdzijOo7zzOAK2Zx7qhWvDmrXlwSEXJAPGN+8FRXM0tt57+2IPad9BBNVgWMoGUUiJToErXiyQq2Aq64UVzPin2cIebhHptrOV1pDc9PFMDZvHMk0xWY3/uATYzZcElrDVosjlISaLhlAK/HFTeKB7L6Gi7yM/HJfWPwyVF+qhCRXukZwGFzDKEie+gmYz4g/eW72A48RT9XmiqSJNTOw5eOPi25DXdTzlwdeyDrc84Qc2FsWJ4/Ix5PUfnGhrw8Jcbmbge7jz7D3pOnexnzsDpy7S9YtiP3ygFCnSQJVTxUrVZLcMVLq2uXVtc//F34S9a5nCGmYbAR89aDaP55HeHwDCWp3XlwhjBaVqPEXdF01F8B6zBHdqojVlFMa8aQBqy9WAxLVzbHWtZ/vVgSjpp0Gdebp9d9uXhBfCBhc/0Z/A+0rG2cI6aj/trvy3fqY248U7GR3GN69ax/1dZJLatsoLaJukYc9vGU8P+NOjWltjHoyxpz+Ig6+ANVvAhuIAzHgwAAAABJRU5ErkJggg==\n",
      "text/latex": [
       "$$- x \\left(x y \\cos{\\left (x y \\right )} + 2 \\sin{\\left (x y \\right )}\\right)$$"
      ],
      "text/plain": [
       "-x⋅(x⋅y⋅cos(x⋅y) + 2⋅sin(x⋅y))"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "diff(f, x, 1, y, 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
**********************************************************************

Testing MyFirstJupyterNb.ipynb...

======================================================================
Inspecting script file using_os.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: using_os.py
# Date: 25 November 2019

""" Tutorial on using the os module in python
goes through your own directories and returns
file names starting with "C"
"""

### Imports
import os
import subprocess

# Get the user's home directory.
home = subprocess.os.path.expanduser("~")
print(home)

# Use the subprocess.os module to get a list of files and  directories in your ubuntu home directory 
firlist = subprocess.os.listdir(home)
print(firlist)

# Get a list of files and directories in your home/ that start with an uppercase 'C'

FilesDirsStartingWithC = [filename for filename in os.listdir('/home/vlb19') if filename.startswith("C")]
print(FilesDirsStartingWithC)

# Use a for loop to walk through the home directory.
for (root, dirs, files) in subprocess.os.walk(home):
    for name in files: 
        (base, ext) = os.path.splitext(name)
        files = base

  
#################################
# Get files and directories in your home/ that start with either an 
# upper or lower case 'C'

# Type your code here:
FilesDirsStartingWithC = [filename for filename in os.listdir('/home/vlb19') if filename.startswith("C") or filename.startswith("c")]
print(FilesDirsStartingWithC)

**********************************************************************

Testing using_os.py...

using_os.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.5

Output (only first 500 characters): 

**********************************************************************
/home/mhasoba
['.dbus', '.remmina', '.gitconfig', '.zoom', 'Music', '.VirtualBox', '.ssh', '.mume', '.jupyter', '.vscode', '.nano', '.bash_logout', '.mozilla', 'logpath', '.profile', '.python_history', '.sqlite_history', '.ipynb_checkpoints', '.fontconfig', '.bashrc', '.dropbox', '.gtk-bookmarks', '.unison', '.Skype', '.gnome', '.ICEauthority', '.pylint.d', '.desktop_items.txt', '.QtWebEngineProcess', '.julia', '.aspnet', '.sage', '.gphoto', '.sudo_as_admin_successful', 'Desktop', '.cache', 'Pict
**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "using_os.py", line 26, in <module>
    FilesDirsStartingWithC = [filename for filename in os.listdir('/home/vlb19') if filename.startswith("C")]
FileNotFoundError: [Errno 2] No such file or directory: '/home/vlb19'

======================================================================
Inspecting script file LV1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: LV1.py
# Date: 3 December 2019

""" Plotting in Python 
Numerical integration using scipy
The Lotka-Volterra model
"""

# OUTPUT
# Saves one figure with side-by-side plots of 
# Consumer-Resource population dynamics

### Imports

import scipy as sc
import scipy.linalg
import scipy.integrate as integrate

def dCR_dt(pops, t=0):
    
    R = pops[0] #resource population abundance
    C = pops[1] #consumer population abundance
    dRdt = r * R - a * R * C
    dCdt = -z * C + e * a * R * C
    
    return sc.array([dRdt, dCdt])

type(dCR_dt)

# assign parameter values
r = 1. #intrinsic growth rate of the resource population
a = 0.1 #per captita search rate fore the resource (area x time^-1)
z = 1.5 #mortality rate
e = 0.75 #consumer efficiency

#define time vector integrating from time point 0 to 15 using 1000 sub-divisions of time
t = sc.linspace(0, 15, 1000)

# Setting the initial conditions for the two populations (10 resources and 5 consumers per unit area), and convert the two into an array (because our function takes an array as input)

R0 = 10 
C0 = 5
RC0 = sc.array([R0, C0])

# Numerically integrate this system forward from the starting conditions
pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)
pops

type(infodict)

infodict.keys()

infodict['message']

import matplotlib.pylab as p

f1 = p.figure()

p.plot(t, pops[:,0], 'g-', label='Resource density') 
p.plot(t, pops[:,1], 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population density')
p.title('Consumer-Resource population dynamics')

f1.savefig('../results/LV_model.pdf') #Save figure to results folder

f2 = p.figure()
p.plot(pops[:,0], pops[:,1], 'r-', label="Resource density")
p.grid()
p.xlabel('Resource Density')
p.ylabel('Consumer Density')
p.title('Consumer-Resource population dynamics')

f2.savefig('../results/LV_model2.pdf')**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 94.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 1.01397s

======================================================================
Inspecting script file DrawFW.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Create a network plot using data from imported CSV """

__appname__ = '[DrawFW.py]'
__author__ = 'Victoria Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

### Imports
import networkx as nx
import scipy as sc
import matplotlib.pylab as p
import csv
import pandas

### Import csv files 
edges = pandas.read_csv('../data/QMEE_Net_Mat_edges.csv', header =0)
nodes = pandas.read_csv('../data/QMEE_Net_Mat_nodes.csv', header =0)

### Generate a synthetic food web
def GenRdmAdjList(N = 2, C = 0.5):
    """ 
    """
    Ids = range(N)
    ALst = []
    for i in Ids:
        if sc.random.uniform(0,1,1) < C:
             sLnk =c.random.choice(Ids,2).tolist()
            if Lnk[0] != Lnk[1]: #avoid self (e.g., cannibalistic) loops
                ALst.append(Lnk)
    return ALst

### Assign number of species (MaxN) and connectance (C)
MaxN = 30
C = 0.75

### Generate an adjacency list representing a random food web
AdjL = sc.array(GenRdmAdjList(MaxN, C))
AdjL

### Generate species (node) data
Sps = sc.unique(AdjL) # get species ids

### Generate body sizes for the species 
SizRan = ([-10,10]) #use log10 scale
Sizs = sc.random.uniform(SizRan[0],SizRan[1],MaxN)
Sizs

### Visualising the size distribution generated 

p.hist(Sizs) #log10 scale
p.hist(10 ** Sizs) #raw scale
p.close('all') # close all open plot objects

### Use a circular configuration

pos = nx.circular_layout(Sps) # calculate the coordinates using networkx

# Generate a networkx graph object
G = nx.Graph()

# Add nodes and links (edges) to it
G.add_nodes_from(Sps)
G.add_edges_from(tuple(AdjL))

tuple(AdjL)
# Generate node sizes that are proportional to (log) body sizes
NodSizs= 1000 * (Sizs-min(Sizs))/(max(Sizs)-min(Sizs)) 

# Render the graph 
f3 = p.figure()
nx.draw_networkx(G, pos, node_size = NodSizs)

# Save file
f3.savefig('../results/DrawFW.pdf')



**********************************************************************

Testing DrawFW.py...

DrawFW.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 94.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
  File "DrawFW.py", line 30
    if Lnk[0] != Lnk[1]: #avoid self (e.g., cannibalistic) loops
                                                               ^
IndentationError: unindent does not match any outer indentation level

======================================================================
Inspecting script file Nets.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
## Packages
library(igraph) # Load the igraph package

rm(list = ls())

# 	ICL	UoR	CEH	ZSL	CEFAS	Nonacademic/CASE
# ICL	0	0	10	9	5	70
# UoR		0	12	0	2	76
# CEH			0	0	0	6
# ZSL			       0 	0	28
# CEFAS			       0	0
# Nonacademic/CASE                        0

links <- read.csv("../data/QMEE_Net_Mat_edges.csv", header=T, as.is=T)
nodes <- read.csv("../data/QMEE_Net_Mat_nodes.csv", header=T, row.names = 1)

#Create graph object
net <- graph.adjacency(as.matrix(links), mode = "directed", weighted=TRUE, diag=F)
        
#Test plot
# plot(net, edge.arrow.size=1, edge.curved=.1,
#      vertex.color="orange", vertex.frame.color="#555555",
#      vertex.label=V(net)$Type, vertex.label.color="black",
#      vertex.label.cex=.7) 

# Generate colors based on partner type:
colrs <- c("green", "red", "blue")
V(net)$color <- colrs[nodes$Type]

# Set node size based on Number of PIs:
# V(net)$size <- V(net)$Pis*0.9

V(net)$size <- 50

# Set edge width based on weight (PhD Students):
E(net)$width <- E(net)$weight

#change arrow size and edge color:
E(net)$arrow.size <- 1
E(net)$edge.color <- "gray80"

E(net)$width <- 1+E(net)$weight/10

graphics.off()

svg("../results/QMEENet.svg",width=7,height=7)

plot(net, edge.curved=0, vertex.label.color="black") 

legend(x=-1.5, y=-0.1, c("Hosting Partner", "Non-hosting Partner", "University"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)

dev.off()

**********************************************************************

Testing Nets.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Encountered error (or warning):
Loading required package: methods

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union


======================================================================
Inspecting script file run_fmr_R.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# Author: Victoria Blanchard vlb19@imperial.ac.uk
# Script: run_fmr_R.py
# Date: 25 November 2019

""" Execute an R script from a file within the 
R shell in python terminal"""

### Imports
import subprocess

### Script
subprocess.call("/usr/bin/Rscript fmr.R", shell = True) #execute an R script found in fmr.R within the R shell**********************************************************************

Testing run_fmr_R.py...

run_fmr_R.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.0

Output (only first 500 characters): 

**********************************************************************
Reading CSV
Creating graph
null device 
          1 
Finished in R!
 Graph saved in results folder 

**********************************************************************

Code ran without errors

Time consumed = 0.21168s

======================================================================
Inspecting script file LV2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Plotting in Python
Numerical integration using scipy
The Lotka-Volterra model """

__appname__ = '[LV2.py]'
__author__ = 'Victoria Blanchard (vlb19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import scipy as sc
import scipy.linalg
import scipy.integrate as integrate
import sys
import matplotlib.pylab as p


def dCR_dt(pops, t=0):
    
    R = pops[0] #resource population abundance
    C = pops[1] #consumer population abundance
    dRdt = r * R * (1 - R / K) - a * R * C 
    dCdt = -z * C + e * a * R * C
    
    return sc.array([dRdt, dCdt])

type(dCR_dt)

# assign parameter values
if len(sys.argv) == 5:

    r = float(sys.argv[1]) #intrinsic growth rate of the resource population
    a = float(sys.argv[2]) #per captita search rate fore the resource (area x time^-1)
    z = float(sys.argv[3]) #mortality rate
    e = float(sys.argv[4]) #consumer efficiency
    K = float(sys.argv[5])
else: 
    r = 1. #intrinsic growth rate of the resource population
    a = 0.1 #per captita search rate fore the resource (area x time^-1)
    z = 1.5 #mortality rate
    e = 0.75 #consumer efficiency
    K = 35


#define time vector integrating from time point 0 to 15 using 1000 sub-divisions of time
t = sc.linspace(0, 30, 1000)

# Setting the initial conditions for the two populations (10 resources and 5 consumers per unit area), and convert the two into an array (because our function takes an array as input)

R0 = 10 
C0 = 5
RC0 = sc.array([R0, C0])

# Numerically integrate this system forward from the starting conditions
pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)
pops

type(infodict)

infodict.keys()

infodict['message']

#### Plotting Figures

fig, (ax1, ax2) = p.subplots(1,2) # creating two graph plotting areas 

## Plot graph 1
ax1.plot(t, pops[:,0], 'g-', label='Resource density') 
ax1.plot(t, pops[:,1], 'b-', label='Consumer density')
ax1.grid()
ax1.legend(loc='best')
ax1.set(xlabel = 'Time', ylabel = 'Population density')

## Plot graph 2
ax2.plot(pops[:,0], pops[:,1], 'r-', label="Resource density")
ax2.grid()
ax2.set(xlabel = 'Resource Density', ylabel = 'Consumer Density')

## Add parameter values to graph
labelr = ' '.join(("r = ", str(r)))
labela = ' '.join(("a = ", str(a)))
labelz = ' '.join(("z = ", str(z)))
labele = ' '.join(("e = ", str(e)))
parameterlabels = '\n'.join((labelr,labela,labelz,labele))
boxproperties = dict(boxstyle='round', facecolor='white', alpha=0.5)
ax2.text(0.1, 0.95, parameterlabels, transform=ax2.transAxes, fontsize=9, verticalalignment='top', bbox=boxproperties)

## Put super title over the two graphs
fig.suptitle('Consumer-Resource population dynamics')

## Save figure to results folder
fig.savefig('../results/LV2_model.pdf')
**********************************************************************

Testing LV2.py...

LV2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 93.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.75204s

======================================================================
Inspecting script file MyFirstJupyterNb-checkpoint.ipynb...

File contents are:
**********************************************************************
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this is python!\n"
     ]
    }
   ],
   "source": [
    "a = \"this is python!\"; print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0.22.0'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "pd.__version__"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Building and analysing mathematical models in Jupyter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as p"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'sympy'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-9-9cb9a78c3e77>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0;32mimport\u001b[0m \u001b[0msympy\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0msympy\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mscipy\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0msc\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0minit_printing\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'sympy'"
     ]
    }
   ],
   "source": [
    "from sympy import *\n",
    "import scipy as sc\n",
    "init_printing()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = var('x')\n",
    "type(x) #check it's class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "a, b, c = var(\"a, b, c\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = var('x', real=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x.is_imaginary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = Symbol('x', positive=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x > 0\n",
    "x < 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Symbolic equations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "MyFun = (pi + x)**2; MyFun"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
**********************************************************************

Testing MyFirstJupyterNb-checkpoint.ipynb...

======================================================================
======================================================================
Finished running scripts

Ran into 6 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 93.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!